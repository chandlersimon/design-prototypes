<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="prototype:description" content="Interactive cooking mode list with rotary navigation, press-and-hold edit mode, bottom sheet actions, and reorder experience.">
    <title>Cooking Methods Prototype</title>
    <script src="https://kit.fontawesome.com/8dfe425c81.js" crossorigin="anonymous"></script>
    <link rel="stylesheet" href="../../shared/tokens.css">
    <link rel="stylesheet" href="../../shared/prototype-shell.css">
    <link rel="stylesheet" href="../../shared/components/list-item.css">
    <link rel="stylesheet" href="../../shared/components/segment-range.css">
    <link rel="stylesheet" href="../../shared/components/circular-time-dial.css">
    <link rel="stylesheet" href="../../shared/components/heat-slider.css">
    <style>
        body {
            margin: 0;
            padding: 0;
            background: black;
            color: white;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
        }

        :focus,
        :focus-visible {
            outline: none;
        }

        .prototype-container {
            display: flex;
            flex-direction: column;
            align-items: stretch;
            justify-content: flex-start;
            overflow: hidden;
        }

        .flow-view {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
        }

        .flow-view[hidden] {
            display: none;
        }

        #segmentedRangeContainer {
            align-items: center;
            justify-content: flex-start;
            --background-dark: #000;
            --text-tertiary: #979797;
            --text-primary: #fff;
            --segment-range-selected-color: var(--tomato-400, #fa4947);
            --segment-range-unselected-bg: #3d3d3d;
            --segment-range-minimized-selected-bg: #b6b6b6;
            --segment-range-transition-duration: 250ms;
            --segment-range-switch-speed: 250ms;
            --segment-range-height-easing: ease;
            --segment-range-color-easing: ease;
            --segment-range-minimized-height: 13px;
            --segment-range-normal-height: 51px;
        }

        #segmentedRangeContainer .mode-detail-content {
            gap: 24px;
        }

        #segmentedRangeContent {
            display: flex;
            justify-content: center;
            width: 100%;
            padding: 0;
        }

        #segmentedRangeContent .container {
            width: 272px;
        }

        .custom-cook-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .custom-cook-content {
            width: 100%;
            max-width: 640px;
            flex: 1;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            gap: 24px;
            align-items: center;
            text-align: center;
        }

        .custom-cook-body {
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 24px;
            padding: 0 32px 32px;
        }

        .custom-cook-dial-wrapper {
            display: flex;
            justify-content: center;
            width: 100%;
        }

        #customCookDialHost {
            width: 320px;
            height: 320px;
            position: relative;
            transition: transform 300ms ease, filter 300ms ease;
        }

        #customCookDialHost.custom-cook-mode {
            filter: grayscale(1);
        }

        #customCookDialHost.custom-cook-mode.scale-none {
            transform: scale(1);
        }

        #customCookDialHost.custom-cook-mode.scale-0-9 {
            transform: scale(0.9);
        }

        #customCookDialHost.custom-cook-mode.scale-0-8 {
            transform: scale(0.8);
        }

        #customCookDialHost.custom-cook-mode.scale-0-7 {
            transform: scale(0.7);
        }

        #customCookDialHost.custom-cook-mode.scale-0-6 {
            transform: scale(0.6);
        }

        .custom-cook-heat-slider-container {
            width: 100%;
            display: flex;
            justify-content: center;
        }

        #customCookHeatSlider {
            width: 272px;
        }

        .custom-cook-heat-slider-container .heat-slider {
            width: 100%;
        }

        .screen-container {
            width: 100%;
            height: 100%;
            overflow: hidden;
            position: relative;
        }

        .screen-scroll {
            width: 100%;
            height: 100%;
            overflow-y: auto;
            overflow-x: hidden;
            scrollbar-width: none;
        }

        .screen-scroll::-webkit-scrollbar {
            display: none;
        }

        list-item,
        .list-item {
            background: transparent;
            min-height: 48px;
            transition: none;
        }

        list-item.reordered.reorder-at-top::before,
        .list-item.reordered.reorder-at-top::before {
            content: none;
        }

        list-item.reordered.reorder-at-bottom::after,
        .list-item.reordered.reorder-at-bottom::after {
            content: none;
        }

        .cooking-icon {
            width: 26px;
            height: 26px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 26px;
            color: white;
        }

        list-item.disabled .cooking-icon,
        .list-item.disabled .cooking-icon {
            color: #979797;
        }

        list-item.focused .leading-icon,
        .list-item.focused .leading-icon,
        list-item.focused .cooking-icon,
        .list-item.focused .cooking-icon {
            color: black;
        }

        list-item.reordered .leading-icon,
        .list-item.reordered .leading-icon,
        list-item.reordered .cooking-icon,
        .list-item.reordered .cooking-icon {
            color: black;
        }

        .scroll-scrim {
            position: absolute;
            left: 0;
            right: 0;
            height: 70px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s ease;
            z-index: 5;
        }

        .scroll-scrim.visible {
            opacity: 1;
        }

        .scroll-scrim.top {
            top: 0;
            background: linear-gradient(to bottom, rgba(0, 0, 0, 1), rgba(0, 0, 0, 0));
        }

        .scroll-scrim.bottom {
            bottom: 0;
            background: linear-gradient(to top, rgba(0, 0, 0, 1), rgba(0, 0, 0, 0));
        }

        .list-item.reorder-confirmation {
            animation: reorderPulse 0.6s ease-in-out 3;
        }

        .bottom-sheet {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            transform: translateY(100%);
            height: 482px;
            border: double 2px transparent;
            border-radius: 12px 12px 0 0;
            background-image: linear-gradient(black, black),
                              linear-gradient(to top, #000000 0%, #5f5f5f 30%, #5f5f5f 100%);
            background-origin: border-box;
            background-clip: content-box, border-box;
            background-color: black;
            border-bottom: 0;
            transition: transform 0.25s ease-out;
            z-index: 1000;
        }

        .bottom-sheet.sliding-up {
            transition: transform 0.5s ease-out;
        }

        .bottom-sheet.visible {
            transform: translateY(0);
        }

        .bottom-sheet-content {
            padding: 32px 8px 16px 8px;
            height: 100%;
            box-sizing: border-box;
        }

        .bottom-sheet-title {
            color: white;
            margin-bottom: 32px;
            padding: 0 8px;
        }

        .bottom-sheet-gap {
            height: 13px;
        }

        .bottom-sheet-divider {
            height: 2px;
            background: #3D3D3D;
            width: 100%;
            border-radius: 999px;
        }

        .press-indicator {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            width: 100%;
            height: 32px;
            background: #666;
            opacity: 0;
            transition: opacity 0.3s ease;
            z-index: 10000;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .press-indicator.visible {
            opacity: 1;
        }

        .press-indicator.fade-out {
            opacity: 0;
        }

        .press-progress {
            width: 24px;
            height: 24px;
            transform: rotate(-90deg);
            overflow: visible;
        }

        .progress-circle {
            fill: none;
            stroke: white;
            stroke-width: 2;
            stroke-dasharray: 0 75.36;
            transition: none;
        }

        .press-text {
            color: white;
            font-size: 14px;
            font-weight: 500;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
        }

        .mode-detail-container {
            display: flex;
            align-items: center;
        }

        .mode-detail-content {
            width: 100%;
            max-width: 520px;
            margin: 0 auto;
            padding: 0;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            gap: 32px;
            align-items: center;
            text-align: center;
        }

        .mode-detail-header {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 16px;
        }

        .mode-detail-heading {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .mode-detail-heading.text-base {
            gap: 8px;
        }

        .mode-detail-icon {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 19px;
            height: 19px;
            min-width: 19px;
            min-height: 19px;
            font-size: 19px;
            color: inherit;
        }

        .mode-detail-heading.text-base .mode-detail-icon {
            font-size: var(--text-base-size);
        }

        .mode-detail-title {
            margin: 0;
            font-size: 42px;
        }

        .mode-detail-title.text-base-lv2 {
            font-size: var(--text-base-size);
            line-height: var(--text-base-line-height);
            font-weight: var(--text-base-lv2);
            letter-spacing: var(--text-base-letter-spacing);
            margin: 0;
        }

        .mode-detail-subtitle {
            margin: 0;
            color: #b9b9b9;
            font-size: 16px;
            line-height: 1.5;
            max-width: 360px;
        }

        .mode-detail-dial-wrapper {
            width: 100%;
            display: flex;
            justify-content: center;
        }

        .mode-detail-dial {
            width: 320px;
            height: 320px;
        }

        @keyframes reorderPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.4; }
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

    </style>
</head>
<body>
    <div class="outer-container">
        <div class="prototype-container">
            <div class="flow-view" id="mainFlow">
                <div class="screen-container">
                    <div class="scroll-scrim top" id="topScrollScrim"></div>
                    <div class="screen-scroll" id="mainScreen">
                        <!-- List items populated dynamically -->
                    </div>
                    <div class="scroll-scrim bottom" id="bottomScrollScrim"></div>
                </div>


                <!-- Bottom Sheet -->
                <div class="bottom-sheet" id="bottomSheet">
                    <div class="bottom-sheet-content">
                        <div class="bottom-sheet-title text-base-lv3" id="bottomSheetTitle">Edit Toast</div>
                        
                        <list-item class="list-item" state="focused" data-action="toggle-visibility">
                            <span slot="label">Hide</span>
                            <toggle-switch slot="trailing"></toggle-switch>
                        </list-item>

                        <list-item class="list-item" data-action="reorganize">
                            <span slot="label">Reorganize</span>
                            <div slot="trailing" class="arrow-icon"><i class="fa-chevron-right fa-kit"></i></div>
                        </list-item>

                        <list-item class="list-item" data-action="hidden-modes">
                            <span slot="label">Hidden modes</span>
                            <div slot="trailing" class="arrow-icon"><i class="fa-chevron-right fa-kit"></i></div>
                        </list-item>

                        <div class="bottom-sheet-gap"></div>
                        <div class="bottom-sheet-divider"></div>
                        <div class="bottom-sheet-gap"></div>

                        <list-item class="list-item" data-action="system-settings">
                            <span slot="label">System Settings</span>
                            <div slot="trailing" class="arrow-icon"><i class="fa-chevron-right fa-kit"></i></div>
                        </list-item>
                    </div>
                </div>

                <!-- Press Indicator -->
                <div class="press-indicator" id="pressIndicator">
                    <svg class="press-progress" id="pressProgress">
                        <circle class="progress-circle" cx="12" cy="12" r="12"></circle>
                    </svg>
                    <span class="press-text">Hold to edit mode</span>
                </div>
            </div>

            <div class="flow-view mode-detail-container" id="segmentedRangeContainer" hidden aria-hidden="true" tabindex="-1">
                <div class="mode-detail-content segmented-range-content-wrapper">
                    <div class="mode-detail-header">
                        <div class="mode-detail-heading text-base" id="segmentedRangeHeading">
                            <span class="mode-detail-icon" id="segmentedRangeIcon" aria-hidden="true">
                                <i class="fa-mode-toast fa-kit"></i>
                            </span>
                            <h1 class="mode-detail-title text-base-lv2" id="segmentedRangeTitle">Toast</h1>
                        </div>
                        <p class="mode-detail-subtitle" id="segmentedRangeSubtitle" hidden></p>
                    </div>
                    <div id="segmentedRangeContent"></div>
                </div>
            </div>

            <div class="flow-view mode-detail-container" id="modeDetailContainer" hidden aria-hidden="true" tabindex="-1">
                <div class="mode-detail-content">
                    <div class="mode-detail-header">
                        <div class="mode-detail-heading text-base" id="modeDetailHeading">
                            <span class="mode-detail-icon" id="modeDetailIcon" aria-hidden="true">
                                <i class="fa-mode-bake fa-kit"></i>
                            </span>
                            <h1 class="mode-detail-title text-base-lv2" id="modeDetailTitle">Bake</h1>
                        </div>
                        <p class="mode-detail-subtitle" id="modeDetailSubtitle" hidden></p>
                    </div>
                    <div class="mode-detail-dial-wrapper" id="modeDetailDialWrapper">
                        <div class="mode-detail-dial" id="modeDetailDial"></div>
                    </div>
                </div>
            </div>

            <div class="flow-view custom-cook-container" id="customCookContainer" hidden aria-hidden="true" tabindex="-1">
                <div class="mode-detail-content custom-cook-content">
                    <div class="mode-detail-header">
                        <div class="mode-detail-heading text-base" id="customCookHeading">
                            <span class="mode-detail-icon" id="customCookIcon" aria-hidden="true">
                                <i class="fa-mode-dial fa-kit"></i>
                            </span>
                            <h1 class="mode-detail-title text-base-lv2" id="customCookTitle">Custom Cook</h1>
                        </div>
                        <p class="mode-detail-subtitle" id="customCookSubtitle" hidden></p>
                    </div>
                    <div class="custom-cook-body">
                        <div class="custom-cook-dial-wrapper">
                            <div id="customCookDialHost" tabindex="-1"></div>
                        </div>
                        <div class="custom-cook-heat-slider-container" id="customCookHeatSliderContainer">
                            <div id="customCookHeatSlider"></div>
                        </div>
                    </div>
                    <button class="debug-toggle" id="customCookDebugToggle" type="button">Open animation controls</button>
                    <div class="debug-panel" id="customCookDebugPanel">
                        <h3>Debug Controls</h3>

                        <div class="debug-control">
                            <label for="globalTickModeSelect">Global Tick Mode:</label>
                            <select id="globalTickModeSelect">
                                <option value="default">Default (Original tick counts)</option>
                                <option value="72-ticks">72 Ticks (All modes use 72 ticks)</option>
                                <option value="72-continuous" selected>72 Continuous (59 min ticks + 13 hour ticks)</option>
                            </select>
                        </div>

                        <div class="debug-control">
                            <label for="customCookScaleSelect">Custom-Cook Scale Mode:</label>
                            <select id="customCookScaleSelect">
                                <option value="none">None (no scaling)</option>
                                <option value="0.9" selected>0.9x Scale</option>
                                <option value="0.8">0.8x Scale</option>
                                <option value="0.7">0.7x Scale</option>
                                <option value="0.6">0.6x Scale</option>
                            </select>
                        </div>

                        <div class="debug-control">
                            <label for="rapidModeThreshold">Rapid Mode Threshold:</label>
                            <input type="number" id="rapidModeThreshold" min="1" max="120" step="1" value="30" style="width: 100%; padding: 4px; background: #555; color: white; border: 1px solid #666; border-radius: 3px;">
                            <div class="debug-value" id="rapidModeThresholdValue">30 presses</div>
                        </div>

                        <div class="debug-control">
                            <label for="enableScalingSelect">Enable Tick Scaling:</label>
                            <select id="enableScalingSelect">
                                <option value="false" selected>Disabled</option>
                                <option value="true">Enabled</option>
                            </select>
                        </div>

                        <div class="debug-control scaling-control">
                            <label for="currentLength">Current Tick Length:</label>
                            <input type="range" id="currentLength" min="1.5" max="4" step="0.1" value="2.0">
                            <div class="debug-value" id="currentLengthValue">2.0x</div>
                        </div>

                        <div class="debug-control scaling-control">
                            <label for="adjacentFalloff">Adjacent Falloff %:</label>
                            <input type="range" id="adjacentFalloff" min="10" max="50" step="5" value="25">
                            <div class="debug-value" id="adjacentFalloffValue">25%</div>
                        </div>

                        <div class="debug-control scaling-control">
                            <label for="radiusPercent">Affected Radius %:</label>
                            <input type="range" id="radiusPercent" min="5" max="20" step="1" value="10">
                            <div class="debug-value" id="radiusPercentValue">10%</div>
                        </div>

                        <div class="debug-control scaling-control">
                            <label for="autoResetSelect">Auto Reset Scaling:</label>
                            <select id="autoResetSelect">
                                <option value="true">Enabled</option>
                                <option value="false">Disabled</option>
                            </select>
                        </div>

                        <div class="debug-control scaling-control">
                            <label for="resetDelay">Reset Delay (seconds):</label>
                            <input type="number" id="resetDelay" min="0.5" max="10" step="0.05" value="0.45" style="width: 100%; padding: 4px; background: #555; color: white; border: 1px solid #666; border-radius: 3px;">
                            <div class="debug-value" id="resetDelayValue">0.45s</div>
                        </div>

                        <div class="debug-control scaling-control">
                            <label for="alignmentSelect">Tick Alignment:</label>
                            <select id="alignmentSelect">
                                <option value="center">Centered</option>
                                <option value="inward" selected>Inward</option>
                                <option value="outward">Outward</option>
                            </select>
                        </div>

                        <div class="debug-control scaling-control">
                            <label for="curveSelect">Falloff Curve:</label>
                            <select id="curveSelect">
                                <option value="easeIn">Ease In</option>
                                <option value="linear">Linear</option>
                                <option value="easeOut">Ease Out</option>
                                <option value="sine">Sine Wave</option>
                                <option value="exponential" selected>Exponential</option>
                            </select>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <script type="module" src="../list-item/list-item-component.js"></script>
    <script type="module">
        import { SegmentRange } from '../../shared/components/segment-range.js';
        import CircularTimeDial, { BASE_GRAY, createCircularTimeDialDebugSettings } from '../../shared/components/circular-time-dial.js';
        import { HeatSlider } from '../../shared/components/heat-slider.js';
        import '../../shared/components/toggle-switch.js';

        const TEMP_TICK_COUNT = 72;

        
        class CustomCookCircularTimeDial extends CircularTimeDial {
            constructor() {
                const dialHost = document.getElementById('customCookDialHost');
                if (!dialHost) {
                    throw new Error('Custom cook dial host not found');
                }

                super(dialHost, {
                    idPrefix: 'custom-cook',
                    useExistingMarkup: false,
                    autoBindKeys: false,
                    initialMode: 'time',
                    debugRoot: document.getElementById('customCookDebugPanel'),
                    debugSettings: createCircularTimeDialDebugSettings({
                        customCookScaleMode: '0.9'
                    })
                });

                this.heatSliderContainer = document.getElementById('customCookHeatSliderContainer');
                this.heatSliderElement = document.getElementById('customCookHeatSlider');
                this.container = dialHost;
                this.cookingStatus = document.getElementById('custom-cook-cookingStatus');

                this.modeSequence = [1, 0, 2, 0, 1];
                this.modeLoopStartIndex = 2; // Loop back to heat after index 4
                this.modeIndex = 0; // Start at time
                this.currentMode = this.modeSequence[this.modeIndex];
                this.dialModeBeforeHeat = this.currentMode;

                this.heatDistribution = 75;

                // Create heat slider
                this.heatSlider = new HeatSlider(this.heatSliderElement, {
                    initialPosition: this.heatDistribution,
                    showTitle: true,
                    titleText: 'HEAT DISTRIBUTION',
                    enableShortcuts: false,
                    stepMode: 'preset',
                    onChange: ({ topPct }) => {
                        this.heatDistribution = topPct;
                    }
                });
                this.setHeatSliderEnabled(false);

                const customCookScaleSelect = this.getDebugElement('customCookScaleSelect');
                if (customCookScaleSelect) {
                    customCookScaleSelect.value = this.debugSettings.customCookScaleMode;
                    customCookScaleSelect.addEventListener('change', (e) => {
                        this.debugSettings.customCookScaleMode = e.target.value;
                        this.updateModeVisuals();
                    });
                }

                this.setHeatDistribution(75);

                // Set initial state
                this.updateModeVisuals();
                this.render();
            }
            ensureStatusElements() {
                if (!this.cookingStatus) {
                    this.cookingStatus = document.getElementById('custom-cook-cookingStatus');
                    if (this.cookingStatus) {
                        this.cookingStatus.style.display = 'none';
                        this.cookingStatus.textContent = '';
                    }
                }
            }

            // Heat slider functionality
            clamp01(v) {
                return Math.max(0, Math.min(100, Math.round(Number(v) || 0)));
            }
            
            getHeatDistribution() {
                if (this.heatSlider) {
                    return this.heatSlider.getPosition();
                }
                return this.heatDistribution;
            }
            
            setHeatDistribution(v) {
                const topPct = this.clamp01(v);
                if (this.heatSlider) {
                    this.heatSlider.setPosition(topPct);
                }
                this.heatDistribution = topPct;
            }
            

            adjustHeatDistribution(delta) {
                if (this.currentMode !== 2) return; // Only work in heat mode
                
                const current = this.getHeatDistribution();
                const presets = [0, 25, 50, 75, 100];
                const currentIndex = presets.findIndex(preset => Math.abs(preset - current) <= 2);
                
                let newIndex;
                if (currentIndex === -1) {
                    // Not on a preset, find closest
                    newIndex = delta < 0 
                        ? presets.findIndex(preset => preset >= current) - 1
                        : presets.findIndex(preset => preset > current);
                } else {
                    newIndex = currentIndex + (delta < 0 ? -1 : 1);
                }
                
                if (newIndex >= 0 && newIndex < presets.length) {
                    this.setHeatDistribution(presets[newIndex]);
                }
            }
            
            setupEventListeners() {
                // Key handling is coordinated by the hosting flow.
            }

            increaseValue() {
                if (this.countdownMode) return;
                
                if (this.tempMode) {
                    if (this.temperature >= this.maxTemp) {
                        // Only trigger flash once per boundary hit
                        if (!this.hasFlashedAtBoundary && !this.isFlashing) {
                            this.startFlashAnimation();
                            this.hasFlashedAtBoundary = true;
                        }
                        return;
                    }
                    
                    // Reset flash boundary flag when moving away from boundary
                    this.hasFlashedAtBoundary = false;
                    
                    this.lastActionTime = Date.now();
                    if (!this.scalingActive) {
                        this.startScalingAnimation(true);
                    }
                    this.scalingActive = true;
                    
                    // Always increment by 5°F regardless of tick count
                    this.temperature = Math.min(this.temperature + 5, this.maxTemp);
                } else {
                    this.increaseTime();
                }
                this.render();
            }
            
            decreaseValue() {
                if (this.countdownMode) return;
                
                if (this.tempMode) {
                    if (this.temperature <= this.minTemp) {
                        // Only trigger flash once per boundary hit
                        if (!this.hasFlashedAtBoundary && !this.isFlashing) {
                            this.startFlashAnimation();
                            this.hasFlashedAtBoundary = true;
                        }
                        return;
                    }
                    
                    // Reset flash boundary flag when moving away from boundary
                    this.hasFlashedAtBoundary = false;
                    
                    this.lastActionTime = Date.now();
                    if (!this.scalingActive) {
                        this.startScalingAnimation(true);
                    }
                    this.scalingActive = true;
                    
                    // Always decrement by 5°F regardless of tick count
                    this.temperature = Math.max(this.temperature - 5, this.minTemp);
                } else {
                    this.decreaseTime();
                }
                this.render();
            }
            
            
            toggleMode() {
                if (this.countdownMode) return;

                const previousMode = this.currentMode;

                if (this.currentMode === 2) {
                    const dialReturnMode = this.dialModeBeforeHeat ?? 1;
                    this.currentMode = dialReturnMode;

                    if (dialReturnMode === 0) {
                        this.modeIndex = 3;
                    } else {
                        this.modeIndex = 0;
                    }
                } else {
                    if (this.modeIndex >= this.modeSequence.length - 1) {
                        this.modeIndex = this.modeLoopStartIndex;
                    } else {
                        this.modeIndex += 1;
                    }

                    this.currentMode = this.modeSequence[this.modeIndex];

                    if (this.currentMode === 2 && previousMode !== 2) {
                        this.dialModeBeforeHeat = previousMode;
                    }
                }

                this.updateModeVisuals();
                this.render();
            }

            updateModeVisuals() {
                // Clear dial classes
                this.container.classList.remove('custom-cook-mode', 'scale-none', 'scale-0-9', 'scale-0-8', 'scale-0-7', 'scale-0-6');

                if (this.currentMode === 2) {
                    // Heat mode: scale and greyscale the dial
                    this.container.classList.add('custom-cook-mode');
                    const scaleMode = this.debugSettings.customCookScaleMode || '0.9';
                    if (scaleMode !== 'none') {
                        this.container.classList.add('scale-' + scaleMode.replace('.', '-'));
                    } else {
                        this.container.classList.add('scale-none');
                    }

                    // Activate heat slider
                    this.setHeatSliderEnabled(true);

                    // Mirror the previously active dial mode while the slider is open
                    const dialMode = this.dialModeBeforeHeat ?? 1;
                    this.tempMode = (dialMode === 0);
                } else {
                    // Dial mode (time or temp): deactivate heat slider
                    this.setHeatSliderEnabled(false);

                    // Set tempMode based on current dial mode
                    this.tempMode = (this.currentMode === 0);

                    // Remember the current dial mode so heat mode can reflect it
                    this.dialModeBeforeHeat = this.currentMode;
                }
            }
            
            setHeatSliderEnabled(isEnabled) {
                if (!this.heatSlider) {
                    return;
                }

                const isCurrentlyOn = typeof this.heatSlider.isOn === 'function'
                    ? this.heatSlider.isOn()
                    : false;

                if (isCurrentlyOn !== isEnabled && typeof this.heatSlider.toggle === 'function') {
                    this.heatSlider.toggle(isEnabled);
                }

            }
            
            startCooking() {
                if (this.countdownMode) return;
                this.startRingFillAnimation();
            }
            
            startScalingAnimation(toActive) {
                this.animationStartTime = Date.now();
                this.animatingToState = toActive ? 'active' : 'inactive';
                this.animateTransition();
            }
            
            startFlashAnimation() {
                this.isFlashing = true;
                this.flashStartTime = Date.now();
                this.flashCount = 0;
                this.flashVisible = true;
                this.animateFlash();
            }
            
            animateFlash() {
                if (!this.isFlashing) return;
                
                const currentTime = Date.now();
                const elapsed = currentTime - this.flashStartTime;
                const flashDuration = this.debugSettings.flashDuration; // ms per flash (on/off cycle)
                const totalFlashes = this.debugSettings.flashCount;
                
                // Calculate current flash cycle
                const flashCycle = Math.floor(elapsed / flashDuration);
                
                if (flashCycle >= totalFlashes * 2) {
                    // Animation complete
                    this.isFlashing = false;
                    this.flashVisible = true;
                    this.render();
                    return;
                }
                
                // Toggle visibility every flash duration
                this.flashVisible = (flashCycle % 2 === 0);
                this.render();
                
                requestAnimationFrame(() => this.animateFlash());
            }
            
            animateTransition() {
                const currentTime = Date.now();
                const elapsed = currentTime - this.animationStartTime;
                const progress = Math.min(elapsed / this.animationDuration, 1);
                
                // Ease function
                const easeProgress = 1 - Math.pow(1 - progress, 3);
                
                this.animationProgress = easeProgress;
                this.render();
                
                if (progress < 1) {
                    requestAnimationFrame(() => this.animateTransition());
                } else {
                    this.animationStartTime = null;
                    this.animatingToState = null;
                    this.animationProgress = null;
                }
            }
            
            startTrailDirectionAnimation(targetDirection) {
                // Don't start animation if already at target
                if (this.trailDirection === targetDirection) return;
                
                // Don't start animation if at or near boundaries (to prevent glitches)
                const trailThreshold = 0.2; // 20% threshold for trail interference
                
                if (this.tempMode) {
                    const tempRange = this.maxTemp - this.minTemp;
                    const tempThresholdRange = tempRange * trailThreshold;
                    const nearMinTemp = this.temperature <= (this.minTemp + tempThresholdRange);
                    const nearMaxTemp = this.temperature >= (this.maxTemp - tempThresholdRange);
                    
                    if (nearMinTemp || nearMaxTemp) {
                        // Near boundary - just set direction immediately without animation
                        this.trailDirection = targetDirection;
                        this.trailDirectionTarget = targetDirection;
                        this.render();
                        return;
                    }
                } else {
                    // For time mode, check both phase A and B boundaries
                    if (this.totalMinutes <= 60) {
                        // Phase A: check if near 1 minute or 60 minutes
                        const phaseARange = 59; // 1 to 60 minutes
                        const timeThresholdRange = phaseARange * trailThreshold;
                        const nearMinTime = this.totalMinutes <= (1 + timeThresholdRange);
                        const nearPhaseTransition = this.totalMinutes >= (60 - timeThresholdRange);
                        
                        if (nearMinTime || nearPhaseTransition) {
                            this.trailDirection = targetDirection;
                            this.trailDirectionTarget = targetDirection;
                            this.render();
                            return;
                        }
                    } else {
                        // Phase B: check if near phase transition or max time
                        const phaseBRange = this.maxMinutes - 60;
                        const timeThresholdRange = phaseBRange * trailThreshold;
                        const nearPhaseTransition = this.totalMinutes <= (60 + timeThresholdRange);
                        const nearMaxTime = this.totalMinutes >= (this.maxMinutes - timeThresholdRange);
                        
                        if (nearPhaseTransition || nearMaxTime) {
                            this.trailDirection = targetDirection;
                            this.trailDirectionTarget = targetDirection;
                            this.render();
                            return;
                        }
                    }
                }
                
                this.trailDirectionTarget = targetDirection;
                this.trailDirectionAnimationStart = Date.now();
                this.animateTrailDirection();
            }
            
            animateTrailDirection() {
                if (!this.trailDirectionAnimationStart) return;
                
                const currentTime = Date.now();
                const elapsed = currentTime - this.trailDirectionAnimationStart;
                const progress = Math.min(elapsed / this.trailDirectionAnimationDuration, 1);
                
                // Ease function for smooth transition
                const easeProgress = 1 - Math.pow(1 - progress, 3);
                
                this.render();
                
                if (progress < 1) {
                    requestAnimationFrame(() => this.animateTrailDirection());
                } else {
                    // Animation complete - set final direction
                    this.trailDirection = this.trailDirectionTarget;
                    this.trailDirectionAnimationStart = null;
                    this.render();
                }
            }
            
            startUpdateLoop() {
                setInterval(() => {
                    if (!this.debugSettings.autoReset) return;
                    
                    const timeSinceLastAction = Date.now() - this.lastActionTime;
                    const wasScalingActive = this.scalingActive;
                    
                    if (timeSinceLastAction > (this.debugSettings.resetDelay * 1000)) {
                        if (this.scalingActive) {
                            this.startScalingAnimation(false);
                        }
                        this.scalingActive = false;
                    }
                }, 100); // Check every 100ms
                
                // Countdown update loop
                setInterval(() => {
                    if (this.countdownMode) {
                        this.updateCountdown();
                    }
                }, 100); // Update countdown every 100ms
                
                // Preheat flash loop
                setInterval(() => {
                    if (this.countdownMode && this.preheatPhase) {
                        this.preheatFlashState = !this.preheatFlashState;
                        this.render();
                    }
                }, 600); // Flash every 600ms
            }
            
            formatTime() {
                if (this.totalMinutes < 60) {
                    // Phase A: Show minutes as M:00 (1:00, 2:00, etc.)
                    return `${this.totalMinutes}:00`;
                } else {
                    // Phase B: Show hours and minutes as H:MM
                    const hours = Math.floor(this.totalMinutes / 60);
                    const minutes = this.totalMinutes % 60;
                    return `${hours}:${minutes.toString().padStart(2, '0')}`;
                }
            }
            
            render() {
                // Clear canvas
                this.ctx.fillStyle = 'black';
                this.ctx.fillRect(0, 0, 320, 320);
                
                if (this.cookingComplete) {
                    this.renderCompletionMode();
                } else if (this.ringFillAnimation) {
                    this.renderRingFillAnimation();
                } else if (this.countdownMode) {
                    this.renderCountdownMode();
                } else {
                    if (this.tempMode) {
                        this.renderTemperatureMode();
                    } else {
                        if (this.totalMinutes < 60) {
                            this.renderPhaseA();
                        } else {
                            this.renderPhaseB();
                        }
                    }
                }
                
                // Update display
                if (this.cookingComplete) {
                    this.updateCompletionDisplay();
                } else if (this.ringFillAnimation) {
                    this.updateStartingDisplay();
                } else if (this.countdownMode) {
                    this.updateCountdownDisplay();
                } else {
                    this.updateSetupDisplay();
                }
            }
            
            updateSetupDisplay() {
                this.ensureStatusElements();
                // Hide cooking status during setup
                if (this.cookingStatus) {
                    this.cookingStatus.style.display = 'none';
                }
                
                // Determine label text based on phase
                const labelText = this.totalMinutes < 60 ? 'MIN - SEC' : 'HR - MIN';
                
                if (this.tempMode) {
                    // Temperature mode: temperature is active, time is inactive
                    this.tempDisplay.querySelector('.temp-number').textContent = this.temperature;
                    this.tempDisplay.className = 'temp-display active';
                    // Apply flash visibility to temperature display
                    this.tempDisplay.style.opacity = (this.isFlashing && !this.flashVisible) ? '0' : '1';
                    
                    this.timeDisplayMain.textContent = this.formatTime();
                    this.timeDisplayMain.className = 'time-display-main inactive';
                    this.modeLabel.textContent = labelText;
                    this.modeLabel.style.color = 'var(--text-tertiary)';
                    this.modeLabel.style.opacity = 1.0;
                } else {
                    // Time mode: time is active, temperature is inactive
                    this.tempDisplay.querySelector('.temp-number').textContent = this.temperature;
                    this.tempDisplay.className = 'temp-display inactive';
                    this.timeDisplayMain.textContent = this.formatTime();
                    this.timeDisplayMain.className = 'time-display-main active';
                    // Apply flash visibility to time display
                    this.timeDisplayMain.style.opacity = (this.isFlashing && !this.flashVisible) ? '0' : '1';
                    
                    this.modeLabel.textContent = labelText;
                    this.modeLabel.style.color = 'var(--text-primary)';
                    this.modeLabel.style.opacity = 1.0;
                }
            }
            
            updateStartingDisplay() {
                this.ensureStatusElements();
                // No completion buttons in this flow
                // Keep status label hidden (main component no longer surfaces it)
                if (this.cookingStatus) {
                    this.cookingStatus.style.display = 'none';
                    this.cookingStatus.textContent = '';
                }
                
                this.tempDisplay.querySelector('.temp-number').textContent = this.temperature;
                this.tempDisplay.className = 'temp-display inactive';
                this.timeDisplayMain.textContent = this.formatTime();
                this.timeDisplayMain.className = 'time-display-main active';
                
                // Show appropriate time label below
                this.modeLabel.textContent = this.totalMinutes < 60 ? 'MIN - SEC' : 'HR - MIN';
                this.modeLabel.style.color = 'var(--text-tertiary)';
                this.modeLabel.style.opacity = 1.0;
            }
            
            updateCountdownDisplay() {
                this.ensureStatusElements();
                // No completion buttons in this flow
                // Keep status label hidden; rely on dial visuals instead
                if (this.cookingStatus) {
                    this.cookingStatus.style.display = 'none';
                    this.cookingStatus.textContent = '';
                }

                if (this.preheatPhase && this.debugSettings.preheatEnabled) {
                    // During preheat: show temperature and time set
                    this.tempDisplay.querySelector('.temp-number').textContent = this.temperature;
                    this.tempDisplay.className = 'temp-display inactive';
                    this.timeDisplayMain.textContent = this.formatTime();
                    this.timeDisplayMain.className = 'time-display-main active';
                    
                    // Flash the cooking status above circle
                    const labelOpacity = this.preheatFlashState ? 1.0 : 0.25;
                    if (this.cookingStatus) {
                        this.cookingStatus.style.opacity = labelOpacity;
                    }
                    
                    // Keep original label below (HR-MIN since we're in phase B during cooking)
                    this.modeLabel.textContent = this.totalMinutes < 60 ? 'MIN - SEC' : 'HR - MIN';
                    this.modeLabel.style.color = 'var(--text-tertiary)';
                    this.modeLabel.style.opacity = 1.0;
                } else {
                    // During cooking: show countdown with temperature
                    this.tempDisplay.querySelector('.temp-number').textContent = this.temperature;
                    this.tempDisplay.className = 'temp-display inactive';
                    const { minutes, seconds } = this.getCurrentCountdownTime();
                    
                    // Format time like 1:15 for 1hr 15min, 59:00 for 59min
                    const totalMinutesLeft = minutes;
                    const isUnderOneHour = totalMinutesLeft < 60;
                    
                    if (isUnderOneHour) {
                        // Show as MM:SS format for under 1 hour
                        this.timeDisplayMain.textContent = `${totalMinutesLeft.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                    } else {
                        // Show as H:MM format for 1+ hours
                        const hours = Math.floor(totalMinutesLeft / 60);
                        const mins = totalMinutesLeft % 60;
                        this.timeDisplayMain.textContent = `${hours}:${mins.toString().padStart(2, '0')}`;
                    }
                    
                    this.timeDisplayMain.className = 'time-display-main active';
                    
                    // Show "Actively cooking" above circle
                    if (this.cookingStatus) {
                        this.cookingStatus.style.opacity = 1.0;
                    }
                
                // Show appropriate label below based on time remaining
                    this.modeLabel.textContent = isUnderOneHour ? 'MIN - SEC' : 'HR - MIN';
                    this.modeLabel.style.color = 'var(--text-tertiary)';
                    this.modeLabel.style.opacity = 1.0;
                }
            }
            
            renderTemperatureMode() {
                // Calculate temperature progress and current tick based on global tick mode
                const totalTempTicks = this.getTickCountForMode('tempMode');
                const tempRange = this.maxTemp - this.minTemp; // 180 degrees
                
                let currentTempTick, filledTempTicks, tempIncrement;
                
                if (this.debugSettings.globalTickMode === '72-ticks' || this.debugSettings.globalTickMode === '72-continuous') {
                    // In both 72-ticks and 72-continuous modes, we loop through the temperature range
                    tempIncrement = tempRange / 72;
                    const tempProgress = (this.temperature - this.minTemp) % tempRange;
                    currentTempTick = Math.round(tempProgress / tempIncrement);
                    filledTempTicks = Math.floor((this.temperature - this.minTemp) / tempIncrement) + 1;
                } else {
                    // Default mode
                    tempIncrement = tempRange / TEMP_TICK_COUNT;
                    currentTempTick = Math.round((this.temperature - this.minTemp) / tempIncrement);
                    filledTempTicks = currentTempTick + 1;
                }
                
                for (let i = 0; i < totalTempTicks; i++) {
                    const angle = (i * (360 / totalTempTicks) - 90) * Math.PI / 180;
                    const isFilled = i < filledTempTicks;
                    const isCurrent = i === currentTempTick;
                    
                    // Calculate proximity to current tick for gradual sizing
                    const lengthMultiplier = this.getTickLengthMultiplier(i, currentTempTick, totalTempTicks);
                    
                    this.drawTick(angle, isFilled, isCurrent, false, lengthMultiplier, false, 0, i, currentTempTick, totalTempTicks);
                }
            }
            
            renderRingFillAnimation() {
                const elapsed = Date.now() - this.ringFillStartTime;
                const progress = Math.min(elapsed / this.ringFillDuration, 1);
                
                // Ease-out animation for smoother filling
                const easeProgress = 1 - Math.pow(1 - progress, 2);
                
                // Calculate gap and segments like in countdown mode
                const mainGapAngle = (this.debugSettings.gapAngle * Math.PI) / 180;
                const preheatGapAngle = this.debugSettings.preheatEnabled ? (10 * Math.PI) / 180 : 0;
                const totalGapsAngle = mainGapAngle + preheatGapAngle;
                const availableAngle = 2 * Math.PI - totalGapsAngle;
                
                const topCenter = -Math.PI / 2;
                
                if (this.debugSettings.preheatEnabled) {
                    const preheatPercentage = 0.25;
                    const cookingPercentage = 0.75;
                    const preheatAngle = availableAngle * preheatPercentage;
                    const cookingAngle = availableAngle * cookingPercentage;
                    
                    const preheatStartAngle = topCenter - mainGapAngle / 2;
                    const preheatEndAngle = preheatStartAngle - preheatAngle;
                    const cookingStartAngle = preheatEndAngle - preheatGapAngle;
                    const cookingEndAngle = cookingStartAngle - cookingAngle;
                    
                    // Draw background segments
                    this.ctx.beginPath();
                    this.ctx.arc(this.centerX, this.centerY, this.radius, preheatEndAngle, preheatStartAngle);
                    this.ctx.strokeStyle = '#5a060a';
                    this.ctx.lineWidth = 20;
                    this.ctx.lineCap = 'round';
                    this.ctx.stroke();
                    
                    this.ctx.beginPath();
                    this.ctx.arc(this.centerX, this.centerY, this.radius, cookingEndAngle, cookingStartAngle);
                    this.ctx.strokeStyle = '#5a060a';
                    this.ctx.lineWidth = 20;
                    this.ctx.lineCap = 'round';
                    this.ctx.stroke();
                    
                    // Draw animated fill
                    const totalFillAngle = preheatAngle + cookingAngle;
                    const currentFillAngle = totalFillAngle * easeProgress;
                    
                    if (currentFillAngle > 0) {
                        if (currentFillAngle <= preheatAngle) {
                            // Filling preheat segment
                            const fillEndAngle = preheatStartAngle - currentFillAngle;
                            this.ctx.beginPath();
                            this.ctx.arc(this.centerX, this.centerY, this.radius, fillEndAngle, preheatStartAngle);
                            this.ctx.strokeStyle = '#FA4947';
                            this.ctx.lineWidth = 20;
                            this.ctx.lineCap = 'round';
                            this.ctx.stroke();
                        } else {
                            // Preheat full, filling cooking segment
                            this.ctx.beginPath();
                            this.ctx.arc(this.centerX, this.centerY, this.radius, preheatEndAngle, preheatStartAngle);
                            this.ctx.strokeStyle = '#FA4947';
                            this.ctx.lineWidth = 20;
                            this.ctx.lineCap = 'round';
                            this.ctx.stroke();
                            
                            const cookingFillAngle = currentFillAngle - preheatAngle;
                            const cookingFillEndAngle = cookingStartAngle - cookingFillAngle;
                            this.ctx.beginPath();
                            this.ctx.arc(this.centerX, this.centerY, this.radius, cookingFillEndAngle, cookingStartAngle);
                            this.ctx.strokeStyle = '#FA4947';
                            this.ctx.lineWidth = 20;
                            this.ctx.lineCap = 'round';
                            this.ctx.stroke();
                        }
                    }
                } else {
                    // No preheat: simple fill animation
                    const startAngle = topCenter + mainGapAngle / 2;
                    const endAngle = startAngle + availableAngle;
                    
                    this.ctx.beginPath();
                    this.ctx.arc(this.centerX, this.centerY, this.radius, startAngle, endAngle);
                    this.ctx.strokeStyle = '#5a060a';
                    this.ctx.lineWidth = 20;
                    this.ctx.lineCap = 'round';
                    this.ctx.stroke();
                    
                    if (easeProgress > 0) {
                        const fillAngle = availableAngle * easeProgress;
                        const fillEndAngle = startAngle + fillAngle;
                        
                        this.ctx.beginPath();
                        this.ctx.arc(this.centerX, this.centerY, this.radius, startAngle, fillEndAngle);
                        this.ctx.strokeStyle = '#FA4947';
                        this.ctx.lineWidth = 20;
                        this.ctx.lineCap = 'round';
                        this.ctx.stroke();
                    }
                }
            }
            
            renderCountdownMode() {
                if (this.countdownDuration === 0) return;
                
                const elapsed = this.countdownStartTime ? (Date.now() - this.countdownStartTime) / 1000 : 0;
                
                // Calculate gap size (in radians) from debug settings
                const mainGapAngle = (this.debugSettings.gapAngle * Math.PI) / 180;
                const preheatGapAngle = this.debugSettings.preheatEnabled ? (10 * Math.PI) / 180 : 0; // 10% gap after preheat
                const totalGapsAngle = mainGapAngle + preheatGapAngle;
                const availableAngle = 2 * Math.PI - totalGapsAngle;
                
                // Calculate preheat and cooking segments
                const preheatPercentage = this.debugSettings.preheatEnabled ? 0.25 : 0; // 25% for preheat
                const cookingPercentage = 1 - preheatPercentage;
                
                const preheatAngle = availableAngle * preheatPercentage;
                const cookingAngle = availableAngle * cookingPercentage;
                
                // Main gap is centered at top: preheat starts after gap and goes counter-clockwise (left)
                const topCenter = -Math.PI / 2;
                const preheatStartAngle = topCenter - mainGapAngle / 2; // Start before main gap (left side)
                const preheatEndAngle = preheatStartAngle - preheatAngle; // Go further counter-clockwise (left)
                
                // Secondary gap and cooking segment start
                const cookingStartAngle = preheatEndAngle - preheatGapAngle;
                const cookingEndAngle = cookingStartAngle - cookingAngle;
                
                if (this.debugSettings.preheatEnabled) {
                    // Draw preheat segment background (dark red)
                    this.ctx.beginPath();
                    this.ctx.arc(this.centerX, this.centerY, this.radius, preheatEndAngle, preheatStartAngle);
                    this.ctx.strokeStyle = '#5a060a';
                    this.ctx.lineWidth = 20;
                    this.ctx.lineCap = 'round';
                    this.ctx.stroke();
                    
                    // Draw cooking segment background (dark red)
                    this.ctx.beginPath();
                    this.ctx.arc(this.centerX, this.centerY, this.radius, cookingEndAngle, cookingStartAngle);
                    this.ctx.strokeStyle = '#5a060a';
                    this.ctx.lineWidth = 20;
                    this.ctx.lineCap = 'round';
                    this.ctx.stroke();
                    
                    if (this.preheatPhase) {
                        // During preheat: unfill preheat segment CLOCKWISE (from left to right, like in the image)
                        const preheatProgress = Math.min(elapsed / 10, 1); // 10 seconds preheat
                        const remainingPreheatProgress = 1 - preheatProgress; // How much is left
                        const remainingPreheatAngle = preheatAngle * remainingPreheatProgress;
                        
                        if (remainingPreheatAngle > 0) {
                            // Draw from the END, keeping the right portion (near the gap)
                            const currentPreheatStartAngle = preheatEndAngle + remainingPreheatAngle;
                            this.ctx.beginPath();
                            this.ctx.arc(this.centerX, this.centerY, this.radius, preheatEndAngle, currentPreheatStartAngle);
                            this.ctx.strokeStyle = '#FA4947';
                            this.ctx.lineWidth = 20;
                            this.ctx.lineCap = 'round';
                            this.ctx.stroke();
                        }
                        
                        // Keep cooking segment full during preheat
                        this.ctx.beginPath();
                        this.ctx.arc(this.centerX, this.centerY, this.radius, cookingEndAngle, cookingStartAngle);
                        this.ctx.strokeStyle = '#FA4947';
                        this.ctx.lineWidth = 20;
                        this.ctx.lineCap = 'round';
                        this.ctx.stroke();
                    } else {
                        // During cooking: cooking segment unfills CLOCKWISE (same direction as preheat)
                        const cookingProgress = 1 - Math.min(elapsed / this.countdownDuration, 1);
                        const remainingCookingAngle = cookingAngle * cookingProgress;
                        
                        if (remainingCookingAngle > 0) {
                            // Draw from the END, keeping the right portion (clockwise unfilling)
                            const currentCookingStartAngle = cookingEndAngle + remainingCookingAngle;
                            this.ctx.beginPath();
                            this.ctx.arc(this.centerX, this.centerY, this.radius, cookingEndAngle, currentCookingStartAngle);
                            this.ctx.strokeStyle = '#FA4947';
                            this.ctx.lineWidth = 20;
                            this.ctx.lineCap = 'round';
                            this.ctx.stroke();
                        }
                    }
                } else {
                    // No preheat: standard behavior - starts from top and goes clockwise
                    const remaining = Math.max(0, this.countdownDuration - elapsed);
                    const progress = 1 - Math.min(elapsed / this.countdownDuration, 1);
                    
                    const startAngle = topCenter + mainGapAngle / 2;
                    const endAngle = startAngle + availableAngle;
                    
                    // Draw dark red background ring
                    this.ctx.beginPath();
                    this.ctx.arc(this.centerX, this.centerY, this.radius, startAngle, endAngle);
                    this.ctx.strokeStyle = '#5a060a';
                    this.ctx.lineWidth = 20;
                    this.ctx.lineCap = 'round';
                    this.ctx.stroke();
                    
                    // Draw bright red progress ring
                    if (progress > 0) {
                        const progressAngle = progress * availableAngle;
                        const progressEndAngle = startAngle + progressAngle;
                        
                        this.ctx.beginPath();
                        this.ctx.arc(this.centerX, this.centerY, this.radius, startAngle, progressEndAngle);
                        this.ctx.strokeStyle = '#FA4947';
                        this.ctx.lineWidth = 20;
                        this.ctx.lineCap = 'round';
                        this.ctx.stroke();
                    }
                }
            }
            
            renderPhaseA() {
                const totalTicks = this.getTickCountForMode('phaseA');
                
                let filledTicks, currentTickIndex;
                
                if (this.debugSettings.globalTickMode === '72-ticks') {
                    // In 72-ticks mode, map 1-59 minutes to 72 ticks with looping
                    const minuteProgress = Math.max(1, Math.min(this.totalMinutes, 59));
                    filledTicks = Math.ceil(minuteProgress * 72 / 59);
                    currentTickIndex = filledTicks - 1;
                } else if (this.debugSettings.globalTickMode === '72-continuous') {
                    // In 72-continuous mode, use first 59 ticks for minutes 1-59 (1:1 mapping)
                    const minuteProgress = Math.max(1, Math.min(this.totalMinutes, 59));
                    filledTicks = minuteProgress;
                    currentTickIndex = filledTicks - 1;
                } else {
                    // Default mode - 59 ticks for minutes 1-59
                    filledTicks = Math.max(1, Math.min(this.totalMinutes, 59)); 
                    currentTickIndex = filledTicks - 1;
                }
                
                for (let i = 0; i < totalTicks; i++) {
                    const angle = (i * (360 / totalTicks) - 90) * Math.PI / 180;
                    const isFilled = i < filledTicks;
                    const isCurrent = i === currentTickIndex;
                    
                    // Calculate proximity to current tick for gradual sizing
                    const lengthMultiplier = this.getTickLengthMultiplier(i, currentTickIndex, totalTicks);
                    
                    this.drawTick(angle, isFilled, isCurrent, false, lengthMultiplier, false, 0, i, currentTickIndex, totalTicks);
                }
            }
            
            renderPhaseB() {
                if (this.debugSettings.tickMode === 'hourly') {
                    this.renderPhaseBHourly();
                } else if (this.debugSettings.tickMode === 'wrap') {
                    this.renderPhaseBWrap();
                } else {
                    this.renderPhaseB15Min();
                }
            }
            
            renderPhaseB15Min() {
                const totalTicks = this.getTickCountForMode('phaseB15Min');
                const minutesInPhaseB = this.totalMinutes - 60;
                const ticksInPhaseB = Math.max(1, Math.floor(minutesInPhaseB / 15) + 1); // +1 for 1:00 tick, always at least 1
                const currentTickIndex = ticksInPhaseB - 1;
                
                for (let i = 0; i < totalTicks; i++) {
                    const angle = (i * (360 / totalTicks) - 90) * Math.PI / 180;
                    const isFilled = i < ticksInPhaseB;
                    const isCurrent = i === currentTickIndex;
                    
                    const lengthMultiplier = this.getTickLengthMultiplier(i, currentTickIndex, totalTicks);
                    
                    this.drawTick(angle, isFilled, isCurrent, true, lengthMultiplier, false, 0, i, currentTickIndex, totalTicks);
                }
            }
            
            renderPhaseBWrap() {
                const totalTicks = this.getTickCountForMode('phaseBWrap');
                const minutesInPhaseB = this.totalMinutes - 60;
                
                let currentLap, ticksInCurrentLap, currentTickIndex, incrementsCompleted;
                
                if (this.debugSettings.globalTickMode === '72-continuous') {
                    // In 72-continuous mode, continue from tick 59, then wrap after tick 72
                    incrementsCompleted = Math.floor(minutesInPhaseB / 15) + 1; // +1 to start with 1 increment at 1:00
                    const maxContinuousSlots = 13; // Ticks 60-72 = 13 slots for 15-minute increments
                    
                    if (incrementsCompleted <= maxContinuousSlots) {
                        // First 13 increments: continue from minutes to ticks 60-72
                        currentLap = 0; // Still on the "continuous" progression
                        currentTickIndex = 59 + (incrementsCompleted - 1); // 1st increment -> index 59 (tick 60)
                        ticksInCurrentLap = 59 + incrementsCompleted; // Fill minute ticks + increment ticks
                    } else {
                        // After 13 increments, start wrapping from tick 0
                        const wrappedIncrements = incrementsCompleted - maxContinuousSlots;
                        currentLap = Math.floor((wrappedIncrements - 1) / totalTicks) + 1; // Start lap counting from 1
                        ticksInCurrentLap = ((wrappedIncrements - 1) % totalTicks) + 1; // 1-72
                        currentTickIndex = ticksInCurrentLap - 1; // 0-71
                    }
                } else {
                    // Default wrap mode logic
                    // Each increment is 15 minutes
                    // At 60 min (1:00), we want the first tick filled
                    // At 75 min (1:15), we want the second tick filled, etc.
                    incrementsCompleted = Math.floor(minutesInPhaseB / 15) + 1; // +1 to start with 1 tick at 1:00
                    currentLap = Math.floor((incrementsCompleted - 1) / totalTicks); // Adjust for the +1
                    ticksInCurrentLap = ((incrementsCompleted - 1) % totalTicks) + 1; // Always 1-72
                    currentTickIndex = ticksInCurrentLap - 1;
                }

                for (let i = 0; i < totalTicks; i++) {
                    const angle = (i * (360 / totalTicks) - 90) * Math.PI / 180;
                    
                    let isFilled, showAsGray;
                    
                    if (this.debugSettings.globalTickMode === '72-continuous') {
                        if (currentLap === 0) {
                            // Still in continuous mode: show filled up to current position
                            isFilled = i < ticksInCurrentLap;
                            showAsGray = false; // No gray ticks in continuous mode
                        } else {
                            // In wrap mode after continuous: normal wrap behavior
                            isFilled = i < ticksInCurrentLap;
                            showAsGray = currentLap > 1 && i >= ticksInCurrentLap; // Show gray for previous laps
                        }
                    } else {
                        // Default wrap mode logic
                        isFilled = i < ticksInCurrentLap;
                        showAsGray = currentLap > 0 && i >= ticksInCurrentLap;
                    }
                    
                    const isCurrent = i === currentTickIndex;
                    const lengthMultiplier = this.getTickLengthMultiplier(i, currentTickIndex, totalTicks);
                    this.drawWrapTick(angle, isFilled, isCurrent, currentLap, lengthMultiplier, showAsGray, i, currentTickIndex, totalTicks);
                }
            }
            
            renderPhaseBHourly() {
                const totalTicks = this.getTickCountForMode('phaseBHourly');
                const minutesInPhaseB = this.totalMinutes - 60;
                
                let hoursCompleted, currentTickIndex, filledTicks;
                
                if (this.debugSettings.globalTickMode === '72-ticks') {
                    // In 72-ticks mode, loop through the max time range
                    const maxHours = 72; // Maximum hours in Phase B
                    const hourProgress = Math.floor(minutesInPhaseB / 60) % maxHours;
                    hoursCompleted = Math.max(1, hourProgress + 1);
                    currentTickIndex = (hoursCompleted - 1) % 72;
                    filledTicks = hoursCompleted;
                } else if (this.debugSettings.globalTickMode === '72-continuous') {
                    // In 72-continuous mode, continue seamlessly from minutes to hours
                    // At 1:00 (totalMinutes = 60), we want to be at tick 60 (index 59)
                    // At 2:00 (totalMinutes = 120), we want to be at tick 61 (index 60), etc.
                    
                    const hoursFromStart = Math.floor(this.totalMinutes / 60); // 1, 2, 3, etc.
                    const maxAvailableHours = 13; // Ticks 60-72 = 13 slots
                    
                    if (hoursFromStart > maxAvailableHours) {
                        // Loop when exceeding available slots
                        const loopedHour = ((hoursFromStart - 1) % maxAvailableHours) + 1;
                        currentTickIndex = 58 + loopedHour; // 58 + 1 = 59 (tick 60)
                        filledTicks = 72; // Show all ticks filled when looping
                    } else {
                        // Direct mapping: 1:00 -> tick 60 (index 59), 2:00 -> tick 61 (index 60), etc.
                        currentTickIndex = 59 + (hoursFromStart - 1); // 59 + 0 = 59 (tick 60)
                        filledTicks = 59 + hoursFromStart; // All minute ticks + hour ticks
                    }
                } else {
                    // Default mode
                    hoursCompleted = Math.max(1, Math.floor(minutesInPhaseB / 60) + 1); 
                    currentTickIndex = hoursCompleted - 1;
                    filledTicks = hoursCompleted;
                }
                
                // Calculate progress within current hour for next tick animation
                const minutesInCurrentHour = minutesInPhaseB % 60;
                const hourProgress = minutesInCurrentHour / 60; // 0 to 1
                
                for (let i = 0; i < totalTicks; i++) {
                    const angle = (i * (360 / totalTicks) - 90) * Math.PI / 180;
                    
                    let isFilled;
                    if (this.debugSettings.globalTickMode === '72-continuous') {
                        // In continuous mode: fill first 59 ticks (minutes) + hour ticks
                        isFilled = i < filledTicks;
                    } else {
                        isFilled = i < hoursCompleted;
                    }
                    
                    const isCurrent = i === currentTickIndex;
                    const isNext = i === currentTickIndex + 1 && currentTickIndex + 1 < totalTicks;
                    
                    const lengthMultiplier = this.getTickLengthMultiplier(i, currentTickIndex, totalTicks);
                    
                    this.drawTick(angle, isFilled, isCurrent, true, lengthMultiplier, isNext, hourProgress, i, currentTickIndex, totalTicks);
                }
            }
            
            // Helper methods to get tick counts based on global tick mode setting
            getTickCountForMode(mode) {
                if (this.debugSettings.globalTickMode === '72-ticks') {
                    return 72; // All modes use 72 ticks
                }
                
                if (this.debugSettings.globalTickMode === '72-continuous') {
                    // 72-continuous mode uses 72 ticks for all modes but with different logic
                    return 72;
                }
                
                // Default mode - use original tick counts
                switch(mode) {
                    case 'phaseA': return 59; // Minute mode (1-59 minutes)
                    case 'tempMode': return TEMP_TICK_COUNT + 1; // Temperature + 1 for endpoint
                    case 'phaseBHourly': return 72; // Hourly mode
                    case 'phaseBWrap': return 72; // Wrap mode  
                    case 'phaseB15Min': return 285; // 15-minute mode (71 hours * 4 + 1)
                    default: return 72;
                }
            }
            
            restart() {
                // Reset all values to initial defaults
                this.totalMinutes = 10; // Start with 10 minutes
                this.temperature = 400; // Start with 400°F
                this.tempMode = true; // Start in temperature mode

                this.modeIndex = 0;
                this.currentMode = this.modeSequence[this.modeIndex];
                this.dialModeBeforeHeat = this.currentMode;
                this.dialVisualMode = this.currentMode;
                this.stepsToHeat = this.heatCycleLength;
                this.setHeatSliderEnabled(false);

                // Reset timer and scaling properties
                this.lastActionTime = Date.now();
                this.scalingActive = false;
                
                // Reset trail direction and animation
                this.trailDirection = 'normal';
                this.trailDirectionTarget = 'normal';
                this.trailDirectionAnimationStart = null;
                
                // Reset animation properties
                this.animationStartTime = null;
                this.animatingToState = null;
                this.animationProgress = null;
                this.previousMultipliers = new Map();
                
                // Reset ring fill animation properties
                this.ringFillAnimation = false;
                this.ringFillStartTime = null;
                
                // Reset countdown mode properties
                this.countdownMode = false;
                this.countdownStartTime = null;
                this.countdownDuration = 0;
                this.colonBlinkState = true;
                this.preheatPhase = false;
                this.preheatFlashState = true;

                // Reset completion state
                this.cookingComplete = false;

                // Reset flash animation
                this.isFlashing = false;
                this.flashStartTime = null;
                this.flashCount = 0;
                this.flashVisible = true;
                this.hasFlashedAtBoundary = false;

                this.updateModeVisuals();
                this.render();
            }
            
            renderCompletionMode() {
                // Draw a full green circle
                this.ctx.beginPath();
                this.ctx.arc(this.centerX, this.centerY, this.radius, 0, 2 * Math.PI);
                this.ctx.strokeStyle = '#2BB671';
                this.ctx.lineWidth = 20;
                this.ctx.lineCap = 'round';
                this.ctx.stroke();
            }
            
            updateCompletionDisplay() {
                if (this.cookingStatus) {
                    this.cookingStatus.style.display = 'none';
                    this.cookingStatus.textContent = '';
                }

                this.tempDisplay.querySelector('.temp-number').textContent = this.temperature;
                this.tempDisplay.className = 'temp-display inactive';
                this.timeDisplayMain.textContent = '00:00';
                this.timeDisplayMain.className = 'time-display-main active';
                
                // Change label to "Enjoy"
                this.modeLabel.textContent = 'Enjoy';
                this.modeLabel.style.color = '#2BB671';
                this.modeLabel.style.opacity = 1.0;
            }
            
            increaseTime() {
                if (this.totalMinutes >= this.maxMinutes) {
                    // Only trigger flash once per boundary hit
                    if (!this.hasFlashedAtBoundary && !this.isFlashing) {
                        this.startFlashAnimation();
                        this.hasFlashedAtBoundary = true;
                    }
                    return;
                }
                
                // Reset flash boundary flag when moving away from boundary
                this.hasFlashedAtBoundary = false;
                
                this.lastActionTime = Date.now();
                if (!this.scalingActive) {
                    this.startScalingAnimation(true);
                }
                this.scalingActive = true;
                
                if (this.totalMinutes < 60) {
                    this.totalMinutes += 1;
                } else {
                    this.totalMinutes = Math.min(this.totalMinutes + 15, this.maxMinutes);
                }
                
                this.render();
            }
            
            decreaseTime() {
                if (this.totalMinutes <= 1) {
                    // Only trigger flash once per boundary hit
                    if (!this.hasFlashedAtBoundary && !this.isFlashing) {
                        this.startFlashAnimation();
                        this.hasFlashedAtBoundary = true;
                    }
                    return;
                }
                
                // Reset flash boundary flag when moving away from boundary
                this.hasFlashedAtBoundary = false;
                
                this.lastActionTime = Date.now();
                if (!this.scalingActive) {
                    this.startScalingAnimation(true);
                }
                this.scalingActive = true;
                
                if (this.totalMinutes <= 60) {
                    this.totalMinutes = Math.max(this.totalMinutes - 1, 1); // Stop at 1 minute
                } else {
                    this.totalMinutes = Math.max(this.totalMinutes - 15, 60);
                    if (this.totalMinutes === 60) {
                        this.totalMinutes = 59;
                    }
                }
                
                this.render();
            }
            
            startRingFillAnimation() {
                this.ringFillAnimation = true;
                this.ringFillStartTime = Date.now();
                this.animateRingFill();
            }
            
            animateRingFill() {
                const currentTime = Date.now();
                const elapsed = currentTime - this.ringFillStartTime;
                const progress = Math.min(elapsed / this.ringFillDuration, 1);
                
                this.render();
                
                if (progress < 1) {
                    requestAnimationFrame(() => this.animateRingFill());
                } else {
                    // Animation complete, start actual countdown
                    this.ringFillAnimation = false;
                    this.countdownMode = true;
                    this.countdownDuration = this.totalMinutes * 60;
                    this.countdownStartTime = Date.now();
                    this.colonBlinkState = true;
                    this.preheatFlashState = true;
                    this.preheatPhase = this.debugSettings.preheatEnabled;
                    this.render();
                }
            }
            
            updateCountdown() {
                if (!this.countdownMode || this.countdownStartTime === null) return;
                
                const elapsed = (Date.now() - this.countdownStartTime) / 1000; // seconds
                
                // Handle preheat phase (10 seconds) - only if preheat is enabled
                if (this.preheatPhase && this.debugSettings.preheatEnabled && elapsed >= 10) {
                    this.preheatPhase = false;
                    this.countdownStartTime = Date.now(); // Reset timer for cooking phase
                    this.render();
                    return;
                }
                
                // Handle cooking phase (or immediate cooking if no preheat)
                if (!this.preheatPhase || !this.debugSettings.preheatEnabled) {
                    const remaining = Math.max(0, this.countdownDuration - elapsed);
                    
                    if (remaining <= 0) {
                        // Countdown finished
                        this.countdownMode = false;
                        this.cookingComplete = true;
                        this.totalMinutes = 0;
                    }
                }
                
                this.render();
            }
            
            getCurrentCountdownTime() {
                if (!this.countdownMode || this.countdownStartTime === null) {
                    return { minutes: 0, seconds: 0 };
                }
                
                const elapsed = (Date.now() - this.countdownStartTime) / 1000;
                const remaining = Math.max(0, this.countdownDuration - elapsed);
                
                const minutes = Math.floor(remaining / 60);
                const seconds = Math.floor(remaining % 60);
                
                return { minutes, seconds };
            }
            
            applyCurve(normalizedDistance) {
                // normalizedDistance is 0-1, where 0 is current tick, 1 is edge of affected radius
                switch (this.debugSettings.curve) {
                    case 'linear':
                        return 1 - normalizedDistance;
                    case 'easeOut':
                        return 1 - (normalizedDistance * normalizedDistance);
                    case 'easeIn':
                        return 1 - Math.sqrt(normalizedDistance);
                    case 'sine':
                        return Math.cos(normalizedDistance * Math.PI / 2);
                    case 'exponential':
                        return Math.pow(1 - normalizedDistance, 3);
                    default:
                        return 1 - normalizedDistance;
                }
            }
            
            getTickLengthMultiplier(tickIndex, currentTickIndex, totalTicks) {
                // If scaling is disabled, always return 1.0
                if (!this.debugSettings.scalingEnabled) return 1.0;
                
                if (currentTickIndex === -1) return 1.0; // No current tick
                
                // Calculate base multipliers for active state
                const affectedRadius = Math.floor(totalTicks * (this.debugSettings.radiusPercent / 100));
                let distance = Math.abs(tickIndex - currentTickIndex);
                const wrapDistance = totalTicks - distance;
                distance = Math.min(distance, wrapDistance);
                
                let activeMultiplier = 1.0;
                if (distance === 0) {
                    activeMultiplier = this.debugSettings.currentLength;
                } else if (distance <= affectedRadius) {
                    const falloffAmount = (this.debugSettings.currentLength - 1.0) * (this.debugSettings.adjacentFalloff / 100);
                    const adjacentLength = this.debugSettings.currentLength - falloffAmount;
                    const normalizedDistance = (distance - 1) / (affectedRadius - 1);
                    const curveValue = this.applyCurve(normalizedDistance);
                    const falloffRange = adjacentLength - 1.0;
                    activeMultiplier = 1.0 + (falloffRange * curveValue);
                }
                
                // Handle auto reset and animation states
                if (!this.debugSettings.autoReset) {
                    // No auto reset - use active multiplier if scaling is active, otherwise 1.0
                    return this.scalingActive ? activeMultiplier : 1.0;
                }
                
                // Auto reset is enabled
                if (!this.scalingActive && this.animationStartTime === null) {
                    return 1.0; // Inactive and not animating
                }
                
                if (this.scalingActive && this.animationStartTime === null) {
                    return activeMultiplier; // Active and not animating
                }
                
                // Currently animating
                if (this.animationStartTime !== null && this.animationProgress !== null) {
                    if (this.animatingToState === 'active') {
                        // Animating from 1.0 to activeMultiplier
                        return 1.0 + (activeMultiplier - 1.0) * this.animationProgress;
                    } else {
                        // Animating from activeMultiplier to 1.0
                        return activeMultiplier + (1.0 - activeMultiplier) * this.animationProgress;
                    }
                }
                
                return activeMultiplier;
            }
            
            drawWrapTick(angle, isFilled, isCurrent, currentLap, lengthMultiplier = 1.0, showAsGray = false, tickIndex = -1, currentTickIndex = -1, totalTicks = 0) {
                // Base tick dimensions
                const baseLength = 15;
                const actualLength = baseLength * lengthMultiplier;
                
                let innerRadius, outerRadius;
                const lineWidth = 3;
                
                // Calculate positions based on alignment
                switch (this.debugSettings.alignment) {
                    case 'inward':
                        innerRadius = this.radius - 5 - actualLength;
                        outerRadius = this.radius - 5;
                        break;
                    case 'outward':
                        innerRadius = this.radius - 20;
                        outerRadius = this.radius - 20 + actualLength;
                        break;
                    case 'center':
                        const centerPoint = this.radius - 12.5;
                        const halfLength = actualLength / 2;
                        innerRadius = centerPoint - halfLength;
                        outerRadius = centerPoint + halfLength;
                        break;
                }
                
                // Calculate positions
                const x1 = this.centerX + Math.cos(angle) * innerRadius;
                const y1 = this.centerY + Math.sin(angle) * innerRadius;
                const x2 = this.centerX + Math.cos(angle) * outerRadius;
                const y2 = this.centerY + Math.sin(angle) * outerRadius;
                
                // Use standard coloring system
                let strokeColor;
                
                if (this.debugSettings.gradientColorMode === 'seamless') {
                    // Seamless mode: apply gradient regardless of fill status or showAsGray
                    if (isCurrent) {
                        strokeColor = '#FA4947';
                    } else {
                        strokeColor = this.getConicGradientColor(angle, currentTickIndex, totalTicks, this.debugSettings.gradientColorMode);
                    }
                } else if (showAsGray) {
                    strokeColor = BASE_GRAY;
                } else if (this.debugSettings.gradientColorMode === 'standard') {
                    strokeColor = isFilled ? '#FA4947' : BASE_GRAY;
                } else {
                    // Regular gradient mode: only apply to filled ticks
                    strokeColor = isFilled
                        ? (isCurrent ? '#FA4947' : this.getConicGradientColor(angle, currentTickIndex, totalTicks, this.debugSettings.gradientColorMode))
                        : BASE_GRAY;
                }
                
                // Draw the tick
                this.ctx.save();
                
                this.ctx.beginPath();
                this.ctx.moveTo(x1, y1);
                this.ctx.lineTo(x2, y2);
                this.ctx.strokeStyle = strokeColor;
                this.ctx.lineWidth = lineWidth;
                this.ctx.lineCap = 'round';
                this.ctx.stroke();
                
                this.ctx.restore();
            }
            
            getConicGradientColor(angle, currentTickIndex, totalTicks, mode = 'gradient') {
                // If we don't have a valid current tick, fall back to plain white for that tick only
                if (currentTickIndex < 0 || totalTicks <= 0) return 'rgb(255,255,255)';

                // Normalize: 12 o'clock = 0, increases clockwise [0, 2π)
                let normalizedAngle = (angle + Math.PI / 2) % (2 * Math.PI);
                if (normalizedAngle < 0) normalizedAngle += 2 * Math.PI;

                // Current tick position in radians, 12 o'clock = 0, clockwise
                const currentTickAngle = (currentTickIndex * 2 * Math.PI) / totalTicks;

                if (mode === 'seamless') {
                    // Seamless mode: 20% gradient trail that follows the current position
                    const trailLength = 2 * Math.PI * 0.2; // 20% of full circle
                    
                    // Calculate the start of the gradient trail with animation support
                    const isAnimating = this.trailDirectionAnimationStart !== null;
                    const currentTrailDirection = this.trailDirection;
                    const targetTrailDirection = this.trailDirectionTarget;
                    
                    let animationProgress = 0;
                    if (isAnimating && this.debugSettings.trailMode === 'stay') {
                        const elapsed = Date.now() - this.trailDirectionAnimationStart;
                        animationProgress = Math.min(elapsed / this.trailDirectionAnimationDuration, 1);
                        // Ease function for smooth transition
                        animationProgress = 1 - Math.pow(1 - animationProgress, 3);
                    }
                    
                    const shouldRenderOpposite = this.debugSettings.trailMode === 'stay' && 
                        (currentTrailDirection === 'opposite' || 
                         (isAnimating && targetTrailDirection === 'opposite'));
                    
                    // Calculate both trail positions for potential blending
                    const normalTrailStart = currentTickAngle - trailLength;
                    const oppositeTrailStart = currentTickAngle;
                    
                    let trailStartAngle;
                    if (isAnimating && this.debugSettings.trailMode === 'stay') {
                        // Animate between normal and opposite positions
                        if (currentTrailDirection === 'normal' && targetTrailDirection === 'opposite') {
                            // Animating from normal to opposite
                            trailStartAngle = normalTrailStart + (oppositeTrailStart - normalTrailStart) * animationProgress;
                        } else if (currentTrailDirection === 'opposite' && targetTrailDirection === 'normal') {
                            // Animating from opposite to normal
                            trailStartAngle = oppositeTrailStart + (normalTrailStart - oppositeTrailStart) * animationProgress;
                        } else {
                            trailStartAngle = shouldRenderOpposite ? oppositeTrailStart : normalTrailStart;
                        }
                    } else if (shouldRenderOpposite) {
                        // Trail on opposite side: 20% after current position
                        trailStartAngle = oppositeTrailStart;
                    } else {
                        // Normal trail: 20% before current position
                        trailStartAngle = normalTrailStart;
                    }
                    
                    // Normalize angle
                    if (trailStartAngle < 0) trailStartAngle += 2 * Math.PI;
                    if (trailStartAngle > 2 * Math.PI) trailStartAngle -= 2 * Math.PI;
                    
                    
                    // Check if this tick is within the 20% trail
                    let isInTrail = false;
                    let trailProgress = 0;
                    
                    const tolerance = 0.001; // Small tolerance for floating point comparisons
                    
                    // Calculate trail end angle based on current configuration
                    let trailEndAngle;
                    if (isAnimating && this.debugSettings.trailMode === 'stay') {
                        // During animation, calculate the appropriate end angle
                        if (currentTrailDirection === 'normal' && targetTrailDirection === 'opposite') {
                            // Transitioning from normal (ending at current) to opposite (ending at current + length)
                            const normalEnd = currentTickAngle;
                            const oppositeEnd = (currentTickAngle + trailLength) % (2 * Math.PI);
                            trailEndAngle = normalEnd + (oppositeEnd - normalEnd) * animationProgress;
                        } else if (currentTrailDirection === 'opposite' && targetTrailDirection === 'normal') {
                            // Transitioning from opposite (ending at current + length) to normal (ending at current)
                            const oppositeEnd = (currentTickAngle + trailLength) % (2 * Math.PI);
                            const normalEnd = currentTickAngle;
                            trailEndAngle = oppositeEnd + (normalEnd - oppositeEnd) * animationProgress;
                        } else {
                            trailEndAngle = shouldRenderOpposite ? 
                                (trailStartAngle + trailLength) % (2 * Math.PI) : 
                                currentTickAngle;
                        }
                    } else {
                        trailEndAngle = shouldRenderOpposite ? 
                            (trailStartAngle + trailLength) % (2 * Math.PI) : 
                            currentTickAngle;
                    }
                    
                    // Normalize trail end angle
                    if (trailEndAngle < 0) trailEndAngle += 2 * Math.PI;
                    if (trailEndAngle > 2 * Math.PI) trailEndAngle -= 2 * Math.PI;
                    
                    // Check if this tick is within the trail
                    if (trailStartAngle <= trailEndAngle) {
                        // Normal case: trail doesn't wrap around
                        isInTrail = normalizedAngle >= trailStartAngle - tolerance && normalizedAngle <= trailEndAngle + tolerance;
                        if (isInTrail) {
                            trailProgress = Math.max(0, Math.min(1, (normalizedAngle - trailStartAngle) / trailLength));
                        }
                    } else {
                        // Wrap case: trail wraps around 0/2π boundary
                        isInTrail = normalizedAngle >= trailStartAngle - tolerance || normalizedAngle <= trailEndAngle + tolerance;
                        if (isInTrail) {
                            if (normalizedAngle >= trailStartAngle - tolerance) {
                                trailProgress = Math.max(0, Math.min(1, (normalizedAngle - trailStartAngle) / trailLength));
                            } else {
                                trailProgress = Math.max(0, Math.min(1, (normalizedAngle + 2 * Math.PI - trailStartAngle) / trailLength));
                            }
                        }
                    }
                    
                    if (isInTrail) {
                        // Interpolate within the trail
                        const start = 67;  // BASE_GRAY channel value
                        const end = 255;   // white
                        
                        let r, g, b;
                        if (isAnimating && this.debugSettings.trailMode === 'stay') {
                            // During animation, blend between gradient directions
                            const normalValue = Math.round(start + (end - start) * trailProgress);
                            const oppositeValue = Math.round(end - (end - start) * trailProgress);
                            
                            if (currentTrailDirection === 'normal' && targetTrailDirection === 'opposite') {
                                // Blend from normal to opposite
                                r = Math.round(normalValue + (oppositeValue - normalValue) * animationProgress);
                            } else if (currentTrailDirection === 'opposite' && targetTrailDirection === 'normal') {
                                // Blend from opposite to normal  
                                r = Math.round(oppositeValue + (normalValue - oppositeValue) * animationProgress);
                            } else {
                                r = shouldRenderOpposite ? oppositeValue : normalValue;
                            }
                        } else if (shouldRenderOpposite) {
                            // Opposite trail: white next to current (start), fade to gray (end)
                            r = Math.round(end - (end - start) * trailProgress);
                        } else {
                            // Normal trail: gray at start, white near current (end)
                            r = Math.round(start + (end - start) * trailProgress);
                        }
                        g = r;
                        b = r;
                        return `rgb(${r}, ${g}, ${b})`;
                    } else {
                        // Outside the trail: unaffected gray
                        return BASE_GRAY;
                    }
                } else {
                    // Original gradient mode logic
                    // If current is exactly 12 o'clock, only that tick should be white; others unaffected gray.
                    if (currentTickAngle === 0) {
                        // Only the tick at 12 o'clock should be white (current position).
                        return normalizedAngle === 0 ? 'rgb(255,255,255)' : BASE_GRAY;
                    }

                    // If the tick's angle lies within the sweep [0, currentTickAngle] (clockwise),
                    // map it from BASE_GRAY (start at 12 o'clock) → white (end at current). Outside: unaffected BASE_GRAY.
                    if (normalizedAngle <= currentTickAngle) {
                        const progress = normalizedAngle / currentTickAngle; // 0 → 1

                        // Interpolate from BASE_GRAY (#434343 → 67) to white (255)
                        const start = 67;           // #434343 channel value
                        const end = 255;            // white
                        const r = Math.round(start + (end - start) * progress);
                        const g = r;
                        const b = r;
                        return `rgb(${r}, ${g}, ${b})`;
                    }

                    // Outside the sweep (i.e., after the current tick): unaffected gray
                    return BASE_GRAY;
                }
            }
            
            drawTick(angle, isFilled, isCurrent, isPhaseB, lengthMultiplier = 1.0, isNext = false, progress = 0, tickIndex = -1, currentTickIndex = -1, totalTicks = 0) {
                // Base tick dimensions
                const baseLength = 15; // Base tick length
                const actualLength = baseLength * lengthMultiplier;
                
                let innerRadius, outerRadius;
                
                // Set line width based on phase and tick mode
                let lineWidth;
                if (isPhaseB && this.debugSettings.tickMode === '15min') {
                    lineWidth = 1.5; // Thinner for 15-min mode (285 ticks)
                } else {
                    lineWidth = 3; // Normal thickness for other modes
                }
                
                // Calculate positions based on alignment
                switch (this.debugSettings.alignment) {
                    case 'inward':
                        // Grows inward from outer edge
                        innerRadius = this.radius - 5 - actualLength;
                        outerRadius = this.radius - 5;
                        break;
                    case 'outward':
                        // Grows outward from inner edge
                        innerRadius = this.radius - 20;
                        outerRadius = this.radius - 20 + actualLength;
                        break;
                    case 'center':
                        // Grows from center point
                        const centerPoint = this.radius - 12.5; // Middle of normal tick
                        const halfLength = actualLength / 2;
                        innerRadius = centerPoint - halfLength;
                        outerRadius = centerPoint + halfLength;
                        break;
                }
                
                // Calculate positions
                const x1 = this.centerX + Math.cos(angle) * innerRadius;
                const y1 = this.centerY + Math.sin(angle) * innerRadius;
                const x2 = this.centerX + Math.cos(angle) * outerRadius;
                const y2 = this.centerY + Math.sin(angle) * outerRadius;
                
                // Determine color
                let strokeColor;
                
                if (this.debugSettings.gradientColorMode === 'standard') {
                    // Standard color mode
                    if (isFilled) {
                        strokeColor = '#FA4947'; // Filled ticks are red
                    } else if (isNext && isPhaseB && this.debugSettings.tickMode === 'hourly') {
                        // Next tick in hourly mode cycles through opacity based on progress
                        // Starts grey, then progressively becomes red
                        if (progress === 0) {
                            strokeColor = BASE_GRAY; // Grey when exactly on the hour
                        } else {
                            // Map progress to 25%, 50%, 75%, 100% opacity at quarter intervals
                            let opacity;
                            if (progress < 0.25) {
                                opacity = 0.25 * (progress / 0.25); // 0 to 25%
                            } else if (progress < 0.5) {
                                opacity = 0.25 + 0.25 * ((progress - 0.25) / 0.25); // 25% to 50%
                            } else if (progress < 0.75) {
                                opacity = 0.5 + 0.25 * ((progress - 0.5) / 0.25); // 50% to 75%
                            } else {
                                opacity = 0.75 + 0.25 * ((progress - 0.75) / 0.25); // 75% to 100%
                            }
                            
                            // Create rgba color with calculated opacity
                            const red = 255;
                            const green = 0;
                            const blue = 0;
                            strokeColor = `rgba(${red}, ${green}, ${blue}, ${opacity})`;
                        }
                    } else {
                        strokeColor = BASE_GRAY; // Unfilled ticks are gray
                    }
                } else {
                    // Gradient color modes: current = red, others use conic gradient
                    if (this.debugSettings.gradientColorMode === 'seamless') {
                        // Seamless mode: apply gradient regardless of fill status
                        if (isCurrent) {
                            strokeColor = '#FA4947';
                        } else {
                            strokeColor = this.getConicGradientColor(angle, currentTickIndex, totalTicks, this.debugSettings.gradientColorMode);
                        }
                    } else {
                        // Regular gradient mode: only apply to filled ticks
                        if (isFilled) {
                            strokeColor = isCurrent ? '#FA4947' : this.getConicGradientColor(angle, currentTickIndex, totalTicks, this.debugSettings.gradientColorMode);
                        } else {
                            strokeColor = BASE_GRAY;
                        }
                    }
                }
                
                // Draw the tick with smooth transition
                this.ctx.save();
                
                this.ctx.beginPath();
                this.ctx.moveTo(x1, y1);
                this.ctx.lineTo(x2, y2);
                this.ctx.strokeStyle = strokeColor;
                this.ctx.lineWidth = lineWidth;
                this.ctx.lineCap = 'round';
                this.ctx.stroke();
                
                this.ctx.restore();
            }}

        document.addEventListener('DOMContentLoaded', function() {
            const mainScreen = document.getElementById('mainScreen');
            const bottomSheetItems = document.querySelectorAll('.bottom-sheet list-item');
            const reorganizeItemIndex = Array.from(bottomSheetItems).findIndex(item => item.dataset.action === 'reorganize');
            const bottomSheet = document.getElementById('bottomSheet');
            const bottomSheetTitle = document.getElementById('bottomSheetTitle');
            const pressIndicator = document.getElementById('pressIndicator');
            const pressProgress = document.getElementById('pressProgress');
            const mainFlow = document.getElementById('mainFlow');
            const customCookContainer = document.getElementById('customCookContainer');
            const customCookDialHost = document.getElementById('customCookDialHost');
            const customCookHeatSliderContainer = document.getElementById('customCookHeatSliderContainer');
            const customCookHeatSliderElement = document.getElementById('customCookHeatSlider');
            const customCookDebugToggle = document.getElementById('customCookDebugToggle');
            const customCookDebugPanel = document.getElementById('customCookDebugPanel');
            const segmentedRangeContainer = document.getElementById('segmentedRangeContainer');
            const segmentedRangeContent = document.getElementById('segmentedRangeContent');
            const segmentedRangeHeading = document.getElementById('segmentedRangeHeading');
            const segmentedRangeTitle = document.getElementById('segmentedRangeTitle');
            const segmentedRangeSubtitle = document.getElementById('segmentedRangeSubtitle');
            const segmentedRangeIcon = document.getElementById('segmentedRangeIcon');
            const instructionsBanner = document.querySelector('.instructions');
            const topScrollScrim = document.getElementById('topScrollScrim');
            const bottomScrollScrim = document.getElementById('bottomScrollScrim');
            const modeDetailContainer = document.getElementById('modeDetailContainer');
            const modeDetailHeading = document.getElementById('modeDetailHeading');
            const modeDetailTitle = document.getElementById('modeDetailTitle');
            const modeDetailSubtitle = document.getElementById('modeDetailSubtitle');
            const modeDetailIcon = document.getElementById('modeDetailIcon');
            const modeDetailDialHost = document.getElementById('modeDetailDial');
            const modeDetailDialWrapper = document.getElementById('modeDetailDialWrapper');
            const customCookHeading = document.getElementById('customCookHeading');
            const customCookTitle = document.getElementById('customCookTitle');
            const customCookSubtitle = document.getElementById('customCookSubtitle');
            const customCookIcon = document.getElementById('customCookIcon');
            const hideListItem = bottomSheet ? bottomSheet.querySelector('list-item[data-action="toggle-visibility"]') : null;
            const hideToggle = hideListItem ? hideListItem.querySelector('toggle-switch') : null;
            
            let currentMainIndex = 0;
            let currentBottomIndex = 0;
            let qPressStart = null;
            let qPressTimer = null;
            let qProgressTimer = null;
            let isBottomSheetOpen = false;
            let isReorderMode = false;
            let reorderingIndex = 0; // Index of item being moved
            let currentReorderModes = []; // Copy of modes array for reordering
            let isReorderFeedbackActive = false;
            let isCustomCookOpen = false;
            let isSegmentedRangeOpen = false;
            let isModeDetailOpen = false;
            let activeModeDetail = null;
            let modeDetailDial = null;
            let customCookDial = null;
            let customCookDebugBound = false;

            const cookingModes = [
                'Toast', 'Bagel', 'Bake', 'Air Fry', 'Broil', 'Roast', 'Proof', 'Reheat',
                'Slow Cook', 'Keep Warm', 'Dehydrate', 'Crispy Reheat', 'Bottom Bake',
                'Bottom Broil', 'Outer Broil', 'Custom Cook'
            ];

            const modeIconMap = {
                'Toast': 'mode-toast', 'Bagel': 'mode-bagel', 'Bake': 'mode-bake',
                'Air Fry': 'mode-air-fry', 'Broil': 'mode-broil', 'Roast': 'mode-roast',
                'Proof': 'mode-proof', 'Reheat': 'mode-reheat', 'Slow Cook': 'mode-slow-cook',
                'Keep Warm': 'mode-keep-warm', 'Dehydrate': 'mode-dehydrate', 
                'Crispy Reheat': 'mode-crispy-reheat', 'Bottom Bake': 'mode-bottom-bake',
                'Bottom Broil': 'mode-bottom-broil', 'Outer Broil': 'mode-outer-broil',
                'Custom Cook': 'mode-dial'
            };

            const modeDetailPresets = {
                'Bake': {
                    temperature: 350,
                    totalMinutes: 45
                },
                'Air Fry': {
                    temperature: 400,
                    totalMinutes: 18
                }
            };

            const dialModes = new Set(['Bake', 'Air Fry']);

            const segmentedRangeDefaults = {
                slices: { title: 'Slices', segments: 9, value: 2 },
                darkness: { title: 'Darkness', segments: 7, value: 3 },
            };

            let segmentedRangeInitialized = false;
            let segmentedRangeActiveKey = 'slices';
            const segmentedRangeInstances = {
                slices: null,
                darkness: null,
            };

            const ensureSegmentedRangeInitialized = () => {
                if (segmentedRangeInitialized || !segmentedRangeContent) {
                    return;
                }

                segmentedRangeContent.innerHTML = '';

                segmentedRangeContent.innerHTML = `
                    <div class="container">
                        <div id="slicesRange"></div>
                        <div id="darknessRange"></div>
                    </div>
                `;

                const slicesRoot = segmentedRangeContent.querySelector('#slicesRange');
                const darknessRoot = segmentedRangeContent.querySelector('#darknessRange');

                if (!slicesRoot || !darknessRoot) {
                    return;
                }

                segmentedRangeInstances.slices = new SegmentRange(slicesRoot, {
                    title: segmentedRangeDefaults.slices.title,
                    segments: segmentedRangeDefaults.slices.segments,
                    value: segmentedRangeDefaults.slices.value,
                    expanded: true,
                    active: true,
                });

                segmentedRangeInstances.darkness = new SegmentRange(darknessRoot, {
                    title: segmentedRangeDefaults.darkness.title,
                    variant: 'darkness',
                    segments: segmentedRangeDefaults.darkness.segments,
                    value: segmentedRangeDefaults.darkness.value,
                    expanded: false,
                    active: false,
                });

                segmentedRangeActiveKey = 'slices';
                segmentedRangeInitialized = true;
            };

            const setSegmentedRangeActiveKey = (key) => {
                if (!segmentedRangeInitialized) {
                    return;
                }

                const nextKey = key === 'darkness' ? 'darkness' : 'slices';
                if (segmentedRangeActiveKey === nextKey) {
                    return;
                }

                const current = segmentedRangeInstances[segmentedRangeActiveKey];
                const next = segmentedRangeInstances[nextKey];
                if (!current || !next) {
                    return;
                }

                current.setExpanded(false);
                current.setActive(false);

                next.setExpanded(true);
                next.setActive(true);

                segmentedRangeActiveKey = nextKey;
            };

            const toggleSegmentedRangeActiveKey = () => {
                const next = segmentedRangeActiveKey === 'slices' ? 'darkness' : 'slices';
                setSegmentedRangeActiveKey(next);
            };

            const resetSegmentedRange = () => {
                if (!segmentedRangeInitialized) {
                    return;
                }

                const { slices, darkness } = segmentedRangeInstances;
                if (slices) {
                    slices.setSegments(segmentedRangeDefaults.slices.segments, { preserveValue: true, suppressEvent: true });
                    slices.setValue(segmentedRangeDefaults.slices.value, { suppressEvent: true, forceUpdate: true });
                    slices.setExpanded(true);
                    slices.setActive(true);
                }

                if (darkness) {
                    darkness.setSegments(segmentedRangeDefaults.darkness.segments, { preserveValue: true, suppressEvent: true });
                    darkness.setValue(segmentedRangeDefaults.darkness.value, { suppressEvent: true, forceUpdate: true });
                    darkness.setExpanded(false);
                    darkness.setActive(false);
                }

                segmentedRangeActiveKey = 'slices';
            };

            const handleSegmentedRangeInteraction = (key) => {
                if (!isSegmentedRangeOpen) {
                    return false;
                }

                ensureSegmentedRangeInitialized();

                const activeRange = segmentedRangeInstances[segmentedRangeActiveKey];

                switch (key) {
                    case 'p':
                        if (activeRange && typeof activeRange.increment === 'function') {
                            activeRange.increment();
                        }
                        return true;
                    case 'o':
                        if (activeRange && typeof activeRange.decrement === 'function') {
                            activeRange.decrement();
                        }
                        return true;
                    case 'q':
                        toggleSegmentedRangeActiveKey();
                        return true;
                    case 'r':
                        resetSegmentedRange();
                        return true;
                    default:
                        return false;
                }
            };

            function updateScrollScrims() {
                if (!topScrollScrim || !bottomScrollScrim) {
                    return;
                }

                const scrollableHeight = mainScreen.scrollHeight;
                const visibleHeight = mainScreen.clientHeight;
                const maxScrollTop = Math.max(scrollableHeight - visibleHeight, 0);
                const scrollTop = mainScreen.scrollTop;

                if (maxScrollTop <= 0) {
                    topScrollScrim.classList.remove('visible');
                    bottomScrollScrim.classList.remove('visible');
                    return;
                }

                const hasContentAbove = scrollTop > 1;
                const hasContentBelow = scrollTop < maxScrollTop - 1;

                topScrollScrim.classList.toggle('visible', hasContentAbove);
                bottomScrollScrim.classList.toggle('visible', hasContentBelow);
            }

            mainScreen.addEventListener('scroll', updateScrollScrims, { passive: true });

            function scrollMainSelectionIntoView(item, behavior = 'smooth') {
                if (!item) {
                    return;
                }

                const container = mainScreen;
                const containerHeight = container.clientHeight;

                if (containerHeight <= 0) {
                    return;
                }

                const itemOffsetTop = item.offsetTop;
                const itemHeight = item.offsetHeight;
                const itemCenter = itemOffsetTop + itemHeight / 2;
                const anchor = containerHeight * 0.5;

                let targetScrollTop = itemCenter - anchor;
                const maxScrollTop = Math.max(container.scrollHeight - containerHeight, 0);

                if (targetScrollTop < 0) {
                    targetScrollTop = 0;
                } else if (targetScrollTop > maxScrollTop) {
                    targetScrollTop = maxScrollTop;
                }

                container.scrollTo({
                    top: targetScrollTop,
                    behavior,
                });

                requestAnimationFrame(updateScrollScrims);
            }

            function updateMainFocus(newIndex) {
                const currentMainListItems = mainScreen.querySelectorAll('list-item');
                
                if (currentMainListItems[currentMainIndex]) {
                    currentMainListItems[currentMainIndex].state = 'default';
                }
                
                currentMainIndex = newIndex;
                
                if (currentMainListItems[currentMainIndex]) {
                    currentMainListItems[currentMainIndex].state = 'focused';
                    scrollMainSelectionIntoView(currentMainListItems[currentMainIndex], 'smooth');
                }
            }

            function updateBottomSheetFocus(newIndex) {
                // Remove focused class from current bottom sheet item
                bottomSheetItems[currentBottomIndex].state = 'default';
                
                // Update index
                currentBottomIndex = newIndex;
                
                // Add focused class to new bottom sheet item
                bottomSheetItems[currentBottomIndex].state = 'focused';
            }

            function updateBottomSheetTitle() {
                const selectedMode = cookingModes[currentMainIndex];
                bottomSheetTitle.textContent = `Edit ${selectedMode}`;
            }

            function showPressIndicator() {
                // Remove any fade-out class and add visible for smooth fade-in
                pressIndicator.classList.remove('fade-out');
                pressIndicator.classList.add('visible');
                
                const circle = pressProgress.querySelector('.progress-circle');
                circle.style.strokeDasharray = '0 75.36'; // 12px radius circle circumference
                
                // Animate progress over 1.2 seconds (from 300ms to 1500ms total)
                const duration = 1200;
                const startTime = Date.now();
                
                qProgressTimer = setInterval(() => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    const circumference = 75.36;
                    const dashArray = (progress * circumference) + ' ' + circumference;
                    circle.style.strokeDasharray = dashArray;
                }, 16); // ~60fps
            }

            function hidePressIndicator() {
                pressIndicator.classList.add('fade-out');
                pressIndicator.classList.remove('visible');
                if (qProgressTimer) {
                    clearInterval(qProgressTimer);
                    qProgressTimer = null;
                }
                
                // Remove fade-out class after transition completes
                setTimeout(() => {
                    pressIndicator.classList.remove('fade-out');
                }, 300);
            }

            function showBottomSheet() {
                updateBottomSheetTitle();
                
                // Always reset to "Show on menu" item (index 0) and clear any existing focus
                bottomSheetItems.forEach(item => item.state = 'default');
                currentBottomIndex = 0;
                bottomSheetItems[currentBottomIndex].state = 'focused';
                
                bottomSheet.classList.add('sliding-up');
                bottomSheet.classList.add('visible');
                isBottomSheetOpen = true;
                closeModeDetailFlow();
                closeSegmentedRangeFlow();
            }

            function hideBottomSheet() {
                bottomSheet.classList.remove('sliding-up');
                bottomSheet.classList.remove('visible');
                isBottomSheetOpen = false;
            }

            function toggleCustomCookDebug() {
                if (!customCookDebugPanel || !customCookDebugToggle) {
                    return;
                }

                customCookDebugPanel.classList.toggle('open');
                const isOpen = customCookDebugPanel.classList.contains('open');
                customCookDebugToggle.textContent = isOpen ? 'Close' : 'Open animation controls';
            }

            const ensureCustomCookDial = () => {
                if (customCookDial || !customCookDialHost) {
                    return;
                }

                customCookDial = new CustomCookCircularTimeDial();

                if (!customCookDebugBound && customCookDebugToggle) {
                    customCookDebugToggle.addEventListener('click', toggleCustomCookDebug);
                    customCookDebugBound = true;
                }
                if (customCookDebugToggle) {
                    customCookDebugToggle.textContent = 'Open animation controls';
                }
            };

            function openSegmentedRangeFlow(mode = 'Toast') {
                if (!segmentedRangeContainer || !mainFlow) {
                    return;
                }

                if (isSegmentedRangeOpen) {
                    return;
                }

                hideBottomSheet();
                closeModeDetailFlow();

                if (isCustomCookOpen) {
                    closeCustomCookFlow();
                }

                const headerMode = mode || 'Toast';
                if (segmentedRangeHeading) {
                    segmentedRangeHeading.classList.add('text-base');
                }
                if (segmentedRangeTitle) {
                    segmentedRangeTitle.textContent = headerMode;
                    segmentedRangeTitle.classList.add('text-base-lv2');
                }
                if (segmentedRangeIcon) {
                    const iconClass = modeIconMap[headerMode] || 'mode-toast';
                    segmentedRangeIcon.innerHTML = `<i class="fa-${iconClass} fa-kit"></i>`;
                    segmentedRangeIcon.hidden = false;
                }
                if (segmentedRangeSubtitle) {
                    segmentedRangeSubtitle.textContent = '';
                    segmentedRangeSubtitle.hidden = true;
                }

                segmentedRangeContainer.hidden = false;
                segmentedRangeContainer.setAttribute('aria-hidden', 'false');
                mainFlow.hidden = true;
                mainFlow.setAttribute('aria-hidden', 'true');
                if (instructionsBanner) {
                    instructionsBanner.style.display = 'none';
                }

                ensureSegmentedRangeInitialized();
                resetSegmentedRange();

                isSegmentedRangeOpen = true;
                try {
                    segmentedRangeContainer.focus({ preventScroll: true });
                } catch (_error) {
                    segmentedRangeContainer.focus();
                }
            }

            function closeSegmentedRangeFlow() {
                if (!segmentedRangeContainer || !mainFlow) {
                    return;
                }

                if (!isSegmentedRangeOpen) {
                    return;
                }

                isSegmentedRangeOpen = false;
                segmentedRangeContainer.hidden = true;
                segmentedRangeContainer.setAttribute('aria-hidden', 'true');
                mainFlow.hidden = false;
                mainFlow.setAttribute('aria-hidden', 'false');
                if (instructionsBanner) {
                    instructionsBanner.style.display = '';
                }

                updateMainFocus(currentMainIndex);
            }

            function ensureModeDetailDial() {
                if (modeDetailDial || !modeDetailDialHost) {
                    return;
                }

                modeDetailDial = new CircularTimeDial(modeDetailDialHost, {
                    idPrefix: 'mode-detail',
                    autoBindKeys: false
                });

                if (modeDetailDial && modeDetailDial.debugSettings) {
                    modeDetailDial.debugSettings.autoReset = false;
                }
            }

            function configureModeDetailDial(mode) {
                const usesDial = dialModes.has(mode);
                const preset = modeDetailPresets[mode] || {};

                if (modeDetailHeading) {
                    modeDetailHeading.classList.add('text-base');
                }

                if (modeDetailTitle) {
                    modeDetailTitle.textContent = mode;
                    modeDetailTitle.classList.add('text-base-lv2');
                }

                if (modeDetailIcon) {
                    const iconClass = modeIconMap[mode] || 'mode-dial';
                    modeDetailIcon.innerHTML = `<i class="fa-${iconClass} fa-kit"></i>`;
                    modeDetailIcon.hidden = false;
                }

                if (modeDetailSubtitle) {
                    if (usesDial && preset.subtitle) {
                        modeDetailSubtitle.textContent = preset.subtitle;
                        modeDetailSubtitle.hidden = false;
                    } else {
                        modeDetailSubtitle.textContent = '';
                        modeDetailSubtitle.hidden = true;
                    }
                }

                if (modeDetailDialWrapper) {
                    modeDetailDialWrapper.hidden = !usesDial;
                    modeDetailDialWrapper.setAttribute('aria-hidden', usesDial ? 'false' : 'true');
                }

                if (!usesDial || !modeDetailDial) {
                    return;
                }

                const temperature = preset.temperature ?? modeDetailDial.temperature ?? 375;
                const totalMinutes = preset.totalMinutes ?? modeDetailDial.totalMinutes ?? 20;

                modeDetailDial.temperature = temperature;
                modeDetailDial.totalMinutes = totalMinutes;
                modeDetailDial.tempMode = true;
                modeDetailDial.countdownMode = false;
                modeDetailDial.cookingComplete = false;
                modeDetailDial.ringFillAnimation = false;
                modeDetailDial.preheatPhase = false;
                modeDetailDial.scalingActive = false;
                modeDetailDial.selectedButton = 0;
                modeDetailDial.keyPressHistory = [];
                modeDetailDial.accelerationMultiplier = 1;
                modeDetailDial.rapidMode = false;
                modeDetailDial.hasFlashedAtBoundary = false;
                modeDetailDial.lastActionTime = Date.now();
                modeDetailDial.render();
            }

            function openModeDetailFlow(mode) {
                if (!modeDetailContainer || !mainFlow) {
                    return;
                }

                if (isModeDetailOpen && activeModeDetail === mode) {
                    return;
                }

                const usesDial = dialModes.has(mode);
                if (usesDial) {
                    ensureModeDetailDial();
                    if (!modeDetailDial) {
                        return;
                    }
                }

                closeSegmentedRangeFlow();
                closeCustomCookFlow();
                hideBottomSheet();
                qPressStart = null;

                activeModeDetail = mode;
                configureModeDetailDial(mode);

                modeDetailContainer.hidden = false;
                modeDetailContainer.setAttribute('aria-hidden', 'false');
                mainFlow.hidden = true;
                mainFlow.setAttribute('aria-hidden', 'true');
                if (instructionsBanner) {
                    instructionsBanner.style.display = 'none';
                }

                isModeDetailOpen = true;

                requestAnimationFrame(() => {
                    try {
                        modeDetailContainer.focus({ preventScroll: true });
                    } catch (_error) {
                        /* focus fallback no-op */
                    }
                });
            }

            function closeModeDetailFlow() {
                if (!modeDetailContainer || !mainFlow) {
                    return;
                }

                if (!isModeDetailOpen) {
                    return;
                }

                isModeDetailOpen = false;
                activeModeDetail = null;

                modeDetailContainer.hidden = true;
                modeDetailContainer.setAttribute('aria-hidden', 'true');
                mainFlow.hidden = false;
                mainFlow.setAttribute('aria-hidden', 'false');
                if (instructionsBanner) {
                    instructionsBanner.style.display = '';
                }

                updateMainFocus(currentMainIndex);
            }

            function openCustomCookFlow() {
                if (!customCookContainer || !mainFlow) {
                    return;
                }

                if (isCustomCookOpen) {
                    return;
                }

                closeModeDetailFlow();
                closeSegmentedRangeFlow();

                const mode = 'Custom Cook';
                if (customCookHeading) {
                    customCookHeading.classList.add('text-base');
                }
                if (customCookTitle) {
                    customCookTitle.textContent = mode;
                    customCookTitle.classList.add('text-base-lv2');
                }
                if (customCookIcon) {
                    const iconClass = modeIconMap[mode] || 'mode-dial';
                    customCookIcon.innerHTML = `<i class="fa-${iconClass} fa-kit"></i>`;
                    customCookIcon.hidden = false;
                }
                if (customCookSubtitle) {
                    customCookSubtitle.textContent = '';
                    customCookSubtitle.hidden = true;
                }

                isCustomCookOpen = true;
                customCookContainer.hidden = false;
                customCookContainer.setAttribute('aria-hidden', 'false');
                mainFlow.hidden = true;
                mainFlow.setAttribute('aria-hidden', 'true');
                if (instructionsBanner) {
                    instructionsBanner.style.display = 'none';
                }
                ensureCustomCookDial();
                if (customCookDial && typeof customCookDial.restart === 'function') {
                    customCookDial.restart();
                }
                requestAnimationFrame(() => {
                    try {
                        if (customCookDialHost && typeof customCookDialHost.focus === 'function') {
                            customCookDialHost.focus({ preventScroll: true });
                        }
                    } catch (_error) {
                        customCookContainer.focus({ preventScroll: true });
                    }
                });
            }

            function closeCustomCookFlow() {
                if (!customCookContainer || !mainFlow) {
                    return;
                }
                
                if (!isCustomCookOpen) {
                    return;
                }
                isCustomCookOpen = false;
                customCookContainer.hidden = true;
                customCookContainer.setAttribute('aria-hidden', 'true');
                mainFlow.hidden = false;
                mainFlow.setAttribute('aria-hidden', 'false');
                if (instructionsBanner) {
                    instructionsBanner.style.display = '';
                }
                if (customCookDebugPanel) {
                    customCookDebugPanel.classList.remove('open');
                }
                if (customCookDebugToggle) {
                    customCookDebugToggle.textContent = 'Open animation controls';
                }
                updateMainFocus(currentMainIndex);
            }


            window.addEventListener('message', (event) => {
                const allowedOrigins = [window.location.origin, 'null'];
                if (event.origin && !allowedOrigins.includes(event.origin)) {
                    return;
                }
                if (event.data && event.data.type === 'segmented-range-close') {
                    closeSegmentedRangeFlow();
                }
            });

            function showReorderScreen() {
                // Set up reorder mode
                isReorderMode = true;
                reorderingIndex = currentMainIndex; // Start with the selected item
                currentReorderModes = [...cookingModes]; // Make a copy of the array
                
                // Hide bottom sheet
                hideBottomSheet();
                
                // Update main screen for reorder mode
                updateMainScreenForReorder();
                
                // Update state
                isBottomSheetOpen = false;
                requestAnimationFrame(updateScrollScrims);
            }

            function updateMainScreenForReorder() {               
                const listItems = mainScreen.querySelectorAll('list-item');
                listItems.forEach((item, index) => {
                    const isBeingReordered = index === reorderingIndex;
                    
                    item.classList.remove('reorder-confirmation');
                    item.state = isBeingReordered ? 'reordered' : 'disabled';
                    item.classList.toggle('reorder-at-top', isBeingReordered && reorderingIndex === 0);
                    item.classList.toggle('reorder-at-bottom', isBeingReordered && reorderingIndex === currentReorderModes.length - 1);
                });
                
                scrollReorderingItemIntoView('auto');
                requestAnimationFrame(updateScrollScrims);
            }

            function moveItemUp() {
                if (reorderingIndex > 0) {
                    // Swap with previous item
                    const temp = currentReorderModes[reorderingIndex];
                    currentReorderModes[reorderingIndex] = currentReorderModes[reorderingIndex - 1];
                    currentReorderModes[reorderingIndex - 1] = temp;
                    
                    // Update reordering index
                    reorderingIndex--;
                    
                    // Refresh the main screen display
                    refreshMainScreenForReorder('smooth');
                }
            }

            function moveItemDown() {
                if (reorderingIndex < currentReorderModes.length - 1) {
                    // Swap with next item
                    const temp = currentReorderModes[reorderingIndex];
                    currentReorderModes[reorderingIndex] = currentReorderModes[reorderingIndex + 1];
                    currentReorderModes[reorderingIndex + 1] = temp;
                    
                    // Update reordering index
                    reorderingIndex++;
                    
                    // Refresh the main screen display
                    refreshMainScreenForReorder('smooth');
                }
            }

            function confirmReorder() {
                // Update the main cooking modes array
                cookingModes.length = 0;
                cookingModes.push(...currentReorderModes);
                
                // Update current index to new position
                currentMainIndex = reorderingIndex;
                
                // Reset reorder mode
                isReorderMode = false;
                
                // Refresh main screen back to normal mode
                refreshMainScreen('smooth', true);
                animateReorderFeedback();
                requestAnimationFrame(updateScrollScrims);
            }

            function cancelReorder() {
                if (!isReorderMode) {
                    return;
                }

                isReorderMode = false;
                reorderingIndex = currentMainIndex;
                currentReorderModes = [];
                refreshMainScreen('smooth', true);
                requestAnimationFrame(updateScrollScrims);
            }

            function createListItemElement(mode, iconClass, state = 'default', index = null) {
                const listItem = document.createElement('list-item');
                listItem.classList.add('list-item');
                listItem.setAttribute('label', mode);
                listItem.dataset.mode = mode;
                if (index !== null) {
                    listItem.dataset.index = index;
                }
                
                const trailingIcon = document.createElement('div');
                trailingIcon.slot = 'trailing';
                trailingIcon.className = 'cooking-icon';
                trailingIcon.innerHTML = `<i class="fa-${iconClass} fa-kit"></i>`;
                listItem.appendChild(trailingIcon);
                
                if (state && state !== 'default') {
                    listItem.state = state;
                }

                return listItem;
            }

            function refreshMainScreenForReorder(scrollBehavior = 'auto') {
                mainScreen.innerHTML = '';
                
                currentReorderModes.forEach((mode, index) => {
                    const iconClass = modeIconMap[mode];
                    const state = index === reorderingIndex ? 'reordered' : 'disabled';
                    const listItem = createListItemElement(mode, iconClass, state, index);
                    listItem.classList.toggle('reorder-at-top', state === 'reordered' && reorderingIndex === 0);
                    listItem.classList.toggle('reorder-at-bottom', state === 'reordered' && reorderingIndex === currentReorderModes.length - 1);
                    mainScreen.appendChild(listItem);
                });
                
                scrollReorderingItemIntoView(scrollBehavior);
                requestAnimationFrame(updateScrollScrims);
            }
            
            function refreshMainScreen(scrollBehavior = 'auto', preserveScroll = false) {
                const previousScrollTop = preserveScroll ? mainScreen.scrollTop : null;

                mainScreen.innerHTML = '';
                
                cookingModes.forEach((mode, index) => {
                    const iconClass = modeIconMap[mode];
                    const state = index === currentMainIndex ? 'focused' : 'default';
                    const listItem = createListItemElement(mode, iconClass, state, index);
                    mainScreen.appendChild(listItem);
                });

                if (preserveScroll && previousScrollTop !== null) {
                    mainScreen.scrollTop = previousScrollTop;
                }

                const refreshedItems = mainScreen.querySelectorAll('list-item');
                const focusedItem = refreshedItems[currentMainIndex];
                if (focusedItem) {
                    scrollMainSelectionIntoView(focusedItem, scrollBehavior);
                } else {
                    requestAnimationFrame(updateScrollScrims);
                }
            }

            function scrollReorderingItemIntoView(behavior = 'auto') {
                if (!isReorderMode) {
                    return;
                }
                
                const listItems = mainScreen.querySelectorAll('list-item');
                const targetItem = listItems[reorderingIndex];
                
                if (targetItem) {
                    scrollMainSelectionIntoView(targetItem, behavior);
                }

                requestAnimationFrame(updateScrollScrims);
            }

            refreshMainScreen();
            updateBottomSheetTitle();
            updateScrollScrims();

            function animateReorderFeedback() {
                const listItems = mainScreen.querySelectorAll('list-item');
                
                if (!listItems.length) {
                    return;
                }
                
                const targetItem = listItems[currentMainIndex];
                if (!targetItem) {
                    return;
                }
                
                isReorderFeedbackActive = true;
                
                const previousStates = new Map();
                
                listItems.forEach((item, index) => {
                    if (index !== currentMainIndex) {
                        previousStates.set(item, item.state || 'default');
                        item.state = 'disabled';
                    }
                });
                
                targetItem.classList.add('reorder-confirmation');
                
                targetItem.addEventListener('animationend', function handleAnimationEnd() {
                    targetItem.classList.remove('reorder-confirmation');
                    listItems.forEach((item, index) => {
                        if (index === currentMainIndex) {
                            item.state = 'focused';
                        } else {
                            const previousState = previousStates.get(item) || 'default';
                            item.state = previousState;
                        }
                    });
                    isReorderFeedbackActive = false;
                }, { once: true });
            }

            function handleBackAction() {
                if (isReorderFeedbackActive) {
                    return;
                }

                if (isModeDetailOpen) {
                    closeModeDetailFlow();
                    return;
                }

                if (isSegmentedRangeOpen) {
                    closeSegmentedRangeFlow();
                    return;
                }

                if (isCustomCookOpen) {
                    closeCustomCookFlow();
                    return;
                }

                if (isReorderMode) {
                    cancelReorder();
                    return;
                }

                if (isBottomSheetOpen || qPressStart !== null) {
                    if (qPressTimer) {
                        clearTimeout(qPressTimer);
                        qPressTimer = null;
                    }

                    if (qProgressTimer) {
                        clearInterval(qProgressTimer);
                        qProgressTimer = null;
                    }

                    hidePressIndicator();
                    hideBottomSheet();
                    qPressStart = null;
                }
            }

            document.addEventListener('keydown', function(event) {
                const key = event.key ? event.key.toLowerCase() : '';

                if (isModeDetailOpen) {
                    if (key === 'escape' || key === '2' || key === 'numpad2') {
                        event.preventDefault();
                        closeModeDetailFlow();
                    } else if (key === 'p') {
                        event.preventDefault();
                        if (modeDetailDial && typeof modeDetailDial.increaseValue === 'function') {
                            modeDetailDial.increaseValue();
                        }
                    } else if (key === 'o') {
                        event.preventDefault();
                        if (modeDetailDial && typeof modeDetailDial.decreaseValue === 'function') {
                            modeDetailDial.decreaseValue();
                        }
                    } else if (key === 'q') {
                        event.preventDefault();
                        if (modeDetailDial && typeof modeDetailDial.toggleMode === 'function') {
                            modeDetailDial.toggleMode();
                        }
                    } else if (key === 'enter') {
                        event.preventDefault();
                        if (modeDetailDial && typeof modeDetailDial.startCooking === 'function') {
                            modeDetailDial.startCooking();
                        }
                    }
                    return;
                }

                if (isSegmentedRangeOpen) {
                    if (key === 'escape' || key === '2' || key === 'numpad2') {
                        event.preventDefault();
                        closeSegmentedRangeFlow();
                    } else if (handleSegmentedRangeInteraction(key)) {
                        event.preventDefault();
                    }
                    return;
                }

                if (isCustomCookOpen) {
                    if (key === 'escape' || key === '2' || key === 'numpad2') {
                        event.preventDefault();
                        closeCustomCookFlow();
                    } else if (key === 'p') {
                        event.preventDefault();
                        if (customCookDial && typeof customCookDial.increaseValue === 'function') {
                            customCookDial.increaseValue();
                        }
                    } else if (key === 'o') {
                        event.preventDefault();
                        if (customCookDial && typeof customCookDial.decreaseValue === 'function') {
                            customCookDial.decreaseValue();
                        }
                    } else if (key === 'q') {
                        event.preventDefault();
                        if (customCookDial && typeof customCookDial.toggleMode === 'function') {
                            customCookDial.toggleMode();
                        }
                    } else if (key === 'enter') {
                        event.preventDefault();
                        if (customCookDial && typeof customCookDial.startCooking === 'function') {
                            customCookDial.startCooking();
                        }
                    }
                    return;
                }

                if (isReorderFeedbackActive) {
                    event.preventDefault();
                    return;
                }
                
                if (key === 'q') {
                    event.preventDefault();

                    const selectedMode = cookingModes[currentMainIndex];
                    const isCustomCookFocused = selectedMode === 'Custom Cook';

                    if (!isReorderMode && !isBottomSheetOpen && isCustomCookFocused) {
                        openCustomCookFlow();
                        return;
                    }

                    if (isReorderMode) {
                        // Confirm reorder and return to main screen
                        confirmReorder();
                    } else if (isBottomSheetOpen) {
                        const focusedItem = bottomSheetItems[currentBottomIndex];
                        if (!focusedItem) {
                            return;
                        }

                        const action = focusedItem.dataset.action;
                        if (action === 'toggle-visibility') {
                            const toggle = focusedItem.querySelector('toggle-switch');
                            if (toggle && typeof toggle.toggle === 'function') {
                                toggle.toggle();
                            }
                            return;
                        }

                        if (action === 'reorganize') {
                            showReorderScreen();
                            return;
                        }
                    } else if (qPressStart === null) {
                        qPressStart = Date.now();
                        
                        // Show toast after 300ms
                        qPressTimer = setTimeout(() => {
                            showPressIndicator();
                            
                            // Start bottom sheet animation after 1 second (700ms more)
                            qPressTimer = setTimeout(() => {
                                showBottomSheet();
                                
                                // Hide toast when sheet reaches the top (after 0.5s animation)
                                setTimeout(() => {
                                    hidePressIndicator();
                                }, 500); // Bottom sheet animation duration
                            }, 700); // 1000ms total - 300ms already elapsed
                        }, 300);
                    }
                } else if (key === 'p') {
                    event.preventDefault();
                    if (isReorderMode) {
                        // Move item down in reorder mode
                        moveItemDown();
                    } else if (isBottomSheetOpen) {
                        // Navigate bottom sheet items
                        if (currentBottomIndex < bottomSheetItems.length - 1) {
                            updateBottomSheetFocus(currentBottomIndex + 1);
                        }
                    } else {
                        // Navigate main list items
                        const currentMainListItems = mainScreen.querySelectorAll('list-item');
                        if (currentMainIndex < currentMainListItems.length - 1) {
                            updateMainFocus(currentMainIndex + 1);
                        }
                    }
                } else if (key === 'o') {
                    event.preventDefault();
                    if (isReorderMode) {
                        // Move item up in reorder mode
                        moveItemUp();
                    } else if (isBottomSheetOpen) {
                        // Navigate bottom sheet items
                        if (currentBottomIndex > 0) {
                            updateBottomSheetFocus(currentBottomIndex - 1);
                        }
                    } else {
                        // Navigate main list items
                        const currentMainListItems = mainScreen.querySelectorAll('list-item');
                        if (currentMainIndex > 0) {
                            updateMainFocus(currentMainIndex - 1);
                        }
                    }
                } else if (key === '2' || key === 'numpad2') {
                    event.preventDefault();
                    handleBackAction();
                }
            });

            document.addEventListener('keyup', function(event) {
                const key = event.key ? event.key.toLowerCase() : '';

                if (isModeDetailOpen) {
                    if (key === 'escape' || key === '2' || key === 'numpad2') {
                        event.preventDefault();
                        closeModeDetailFlow();
                    }
                    return;
                }

                if (isSegmentedRangeOpen) {
                    if (key === 'escape' || key === '2' || key === 'numpad2') {
                        event.preventDefault();
                        closeSegmentedRangeFlow();
                    }
                    return;
                }

                if (isCustomCookOpen) {
                    if (key === 'escape' || key === '2' || key === 'numpad2') {
                        event.preventDefault();
                        closeCustomCookFlow();
                    }
                    return;
                }

                if (isReorderFeedbackActive) {
                    event.preventDefault();
                    return;
                }
                
                if (key === 'q' && qPressStart !== null) {
                    event.preventDefault();
                    const pressDuration = Date.now() - qPressStart;
                    
                    // Clear timers
                    if (qPressTimer) {
                        clearTimeout(qPressTimer);
                        qPressTimer = null;
                    }
                    
                    hidePressIndicator();
                    
                    // If released before 1.5 seconds, slide back down
                    if (pressDuration < 1500) {
                        hideBottomSheet();
                        const selectedMode = cookingModes[currentMainIndex];
                        if (selectedMode === 'Toast') {
                            openSegmentedRangeFlow(selectedMode);
                        } else if (selectedMode === 'Custom Cook') {
                            openCustomCookFlow();
                        } else if (selectedMode) {
                            openModeDetailFlow(selectedMode);
                        }
                    } else {
                        // If after 1.5 seconds, finish pulling up
                        showBottomSheet();
                    }
                    
                    qPressStart = null;
                }
            });

            if (hideListItem && hideToggle) {
                const isToggleEvent = (event) => {
                    if (event.composedPath) {
                        const path = event.composedPath();
                        return Array.isArray(path) && path.some((node) => node && node.tagName === 'TOGGLE-SWITCH');
                    }
                    if (event.target && typeof event.target.closest === 'function') {
                        return Boolean(event.target.closest('toggle-switch'));
                    }
                    return false;
                };

                hideListItem.addEventListener('click', (event) => {
                    if (isToggleEvent(event)) return;
                    if (typeof hideToggle.toggle === 'function') {
                        hideToggle.toggle();
                    }
                });
            }
        });
    </script>
</body>
</html>
