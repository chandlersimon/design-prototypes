<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Circular Time Dial</title>
    <style>
        @font-face {
            font-family: 'JaffleNeue';
            src: url('../../fonts/JaffleNeue-SemiBoldSemiCondensed.otf') format('truetype');
            font-weight: normal;
            font-style: normal;
        }
        
        :root {
            /* Color Variables */
            --text-primary: #fff;
            --text-tertiary: #979797;
            --accent: #FA4947;
            
            /* Text Variables */
            --number-5xl-lv2: 84px;
            --number-5xl-lv2-line-height: 0.8;
            --number-5xl-lv2-font: 'JaffleNeue', Arial, sans-serif;
            --number-5xl-lv2-weight: 600;
            --number-5xl-lv2-spacing: 0;
            
            --number-2xl-lv2: 43px;
            --number-2xl-lv2-line-height: 0.8;
            --number-2xl-lv2-font: 'JaffleNeue', Arial, sans-serif;
            --number-2xl-lv2-weight: 600;
            --number-2xl-lv2-spacing: 0;
            
            --label-sm-lv2: 18px;
            --label-sm-lv2-line-height: 23px;
            --label-sm-lv2-font: 'Inter', sans-serif;
            --label-sm-lv2-weight: 500;
            --label-sm-lv2-spacing: 0.08em;
            --label-sm-lv2-features: "ss01" 1, "ss02" 1;
            
            --label-xs-lv2: 14px;
            --label-xs-lv2-line-height: 18px;
            --label-xs-lv2-font: 'Inter', sans-serif;
            --label-xs-lv2-weight: 500;
            --label-xs-lv2-spacing: 0.08em;
            --label-xs-lv2-features: "ss01" 1, "ss02" 1;
        }
        body {
            margin: 0;
            padding: 0;
            background: black;
            color: white;
            font-family: 'JaffleNeue', Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
        }

        .outer-container {
            width: 400px;
            height: 600px;
            background: transparent;
            border: 1px solid #444;
            border-top-right-radius: 75px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .prototype-container {
            width: 272px;
            height: 480px;
            background: transparent;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }
        
        .container {
            position: relative;
            width: 320px;
            height: 320px;
        }
        
        canvas {
            border-radius: 50%;
        }
        
        .center-display {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            pointer-events: none;
            width: 200px;
        }
        
        .temp-display, .time-display-main {
            transition: font-size 400ms cubic-bezier(0.4, 0, 0.2, 1), 
                       color 300ms ease,
                       opacity 300ms ease;
            font-weight: bold;
            line-height: 0.8;
        }
        
        .temp-display {
            font-size: 1.8em;
            display: flex;
            align-items: flex-start;
            justify-content: center;
            gap: 2px;
            margin: 34px 0 4px 0;
        }
        
        .time-display-main {
            font-size: 3.2em;
            margin: 0;
        }
        
        .temp-display.active {
            font-size: var(--number-5xl-lv2);
            line-height: var(--number-5xl-lv2-line-height);
            font-family: var(--number-5xl-lv2-font);
            font-weight: var(--number-5xl-lv2-weight);
            letter-spacing: var(--number-5xl-lv2-spacing);
            color: var(--text-primary);
            opacity: 1;
        }
        
        .temp-display.inactive {
            font-size: var(--number-2xl-lv2);
            line-height: var(--number-2xl-lv2-line-height);
            font-family: var(--number-2xl-lv2-font);
            font-weight: var(--number-2xl-lv2-weight);
            letter-spacing: var(--number-2xl-lv2-spacing);
            color: var(--text-tertiary);
            opacity: 1;
        }
        
        .time-display-main.active {
            font-size: var(--number-5xl-lv2);
            line-height: var(--number-5xl-lv2-line-height);
            font-family: var(--number-5xl-lv2-font);
            font-weight: var(--number-5xl-lv2-weight);
            letter-spacing: var(--number-5xl-lv2-spacing);
            color: var(--text-primary);
            opacity: 1;
        }
        
        .time-display-main.inactive {
            font-size: var(--number-2xl-lv2);
            line-height: var(--number-2xl-lv2-line-height);
            font-family: var(--number-2xl-lv2-font);
            font-weight: var(--number-2xl-lv2-weight);
            letter-spacing: var(--number-2xl-lv2-spacing);
            color: var(--text-tertiary);
            opacity: 1;
        }
        
        .mode-label {
            font-size: var(--label-sm-lv2);
            line-height: var(--label-sm-lv2-line-height);
            font-family: var(--label-sm-lv2-font);
            font-weight: var(--label-sm-lv2-weight);
            font-feature-settings: var(--label-sm-lv2-features);
            letter-spacing: var(--label-sm-lv2-spacing);
            margin: 0;
            color: var(--text-tertiary);
            transition: opacity 300ms ease;
        }
        
        .rack-icon {
            margin: 2px 0 0 0;
            display: flex;
            justify-content: center;
            transition: opacity 300ms ease;
        }
        
        .rack-icon svg {
            width: 33px;
            height: 34px;
        }
        
        .rack-label {
            font-size: var(--label-xs-lv2);
            line-height: var(--label-xs-lv2-line-height);
            font-family: var(--label-xs-lv2-font);
            font-weight: var(--label-xs-lv2-weight);
            font-feature-settings: var(--label-xs-lv2-features);
            letter-spacing: var(--label-xs-lv2-spacing);
            margin: 0 0 8px 0;
            color: var(--text-primary);
            transition: opacity 300ms ease;
        }
        
        .temp-unit {
            font-size: 24px;
            font-family: 'Inter', sans-serif;
            font-weight: 500;
            font-feature-settings: "ss01" 1, "ss02" 1;
            letter-spacing: 0.08em;
            padding-top: 3%;
            transition: padding-top 400ms cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .temp-display.inactive .temp-unit {
            padding-top: 0.5%;
        }
        
        .cooking-status {
            position: absolute;
            top: -75px;
            left: 50%;
            transform: translateX(-50%);
            font-size: var(--label-sm-lv2);
            line-height: var(--label-sm-lv2-line-height);
            font-family: var(--label-sm-lv2-font);
            font-weight: var(--label-sm-lv2-weight);
            font-feature-settings: var(--label-sm-lv2-features);
            letter-spacing: var(--label-sm-lv2-spacing);
            color: #ccc;
            text-align: center;
            display: none;
        }
        
        .completion-buttons {
            position: absolute;
            bottom: -100px;
            left: 50%;
            transform: translateX(-50%);
            display: none;
            flex-direction: column;
            gap: 10px;
            align-items: center;
        }
        
        .completion-btn {
            background: #333;
            color: white;
            border: 2px solid #555;
            padding: 12px 24px;
            border-radius: 8px;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            font-size: 1em;
            cursor: pointer;
            transition: all 300ms ease;
            min-width: 120px;
        }
        
        .completion-btn.active {
            background: #555;
            border-color: #777;
            color: #fff;
        }
        
        .completion-btn:hover {
            background: #444;
        }
        
        .debug-panel {
            position: absolute;
            top: 20px;
            right: -240px;
            background: rgba(40, 40, 40, 0.95);
            padding: 15px;
            border-radius: 8px;
            color: white;
            font-size: 0.8em;
            width: 200px;
            transition: right 0.3s ease;
            z-index: 1000;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
        }
        
        .debug-panel.open {
            right: 20px;
        }
        
        .debug-toggle {
            position: absolute;
            top: 20px;
            left: 20px;
            background: #333;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8em;
            z-index: 1001;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
        }
        
        .debug-panel h3 {
            margin: 0 0 10px 0;
            font-size: 1em;
        }
        
        .debug-control {
            margin: 8px 0;
        }
        
        .debug-control label {
            display: block;
            margin-bottom: 3px;
            font-size: 0.9em;
        }
        
        .debug-control input[type="range"] {
            width: 100%;
            margin: 2px 0;
        }
        
        .debug-control select {
            width: 100%;
            padding: 4px;
            background: #555;
            color: white;
            border: 1px solid #666;
            border-radius: 3px;
            font-size: 0.9em;
        }
        
        .scaling-control {
            transition: opacity 0.3s ease, transform 0.3s ease;
        }
        
        .scaling-control.hidden {
            opacity: 0.3;
            pointer-events: none;
            transform: scale(0.95);
        }
        
        .debug-value {
            color: #ccc;
            font-size: 0.8em;
        }
        .instructions {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            color: #888;
            font-size: 0.9em;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
        }
    </style>
</head>
<body>
    <div class="outer-container">
        <div class="prototype-container">
            <div class="container">
        <div class="cooking-status" id="cookingStatus"></div>
        <canvas id="dial" width="320" height="320"></canvas>
        <div class="center-display">
            <div class="temp-display" id="tempDisplay">
                <div class="temp-unit" style="opacity: 0;">°F</div>
                <div class="temp-number">400</div>
                <div class="temp-unit">°F</div>
            </div>
            <div class="time-display-main" id="timeDisplayMain">10:00</div>
            <div class="mode-label" id="modeLabel">MIN - SEC</div>
            <div class="rack-icon" id="rackIcon">
                <svg width="33" height="34" viewBox="0 0 33 34" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M20.3672 10.293H20.4316C19.916 10.0352 19.2715 9.77734 18.2402 9.77734C15.9199 9.77734 14.2441 11.3887 13.9863 13.7734C14.6953 12.8066 15.8555 12.291 17.209 12.291C19.6582 12.291 21.3984 13.9668 21.3984 16.5449C21.3984 19.123 19.3359 20.8633 16.6934 20.8633C13.5352 20.8633 11.7305 18.2207 11.7305 15.0625C11.7305 10.5508 14.502 7.7793 18.3691 7.7793C19.5293 7.7793 20.4961 8.03711 21.0762 8.42383L20.3672 10.293ZM16.6934 18.8652C17.9824 18.8652 19.0781 18.0273 19.0781 16.5449C19.0781 15.127 17.9824 14.2246 16.6934 14.2246C15.3398 14.2246 14.2441 15.127 14.2441 16.5449C14.2441 17.9629 15.4043 18.8652 16.6934 18.8652ZM5.47852 22.6035H8.37891C8.83008 22.6035 9.28125 22.9902 9.3457 23.4414L9.92578 26.084H23.0742L23.6543 23.4414C23.7188 22.9902 24.1699 22.6035 24.6211 22.6035H27.5215C28.1016 22.6035 28.5527 23.1191 28.5527 23.6348C28.5527 24.2148 28.1016 24.666 27.5215 24.666H25.459L24.9434 27.3086C24.8145 27.7598 24.4277 28.1465 23.9121 28.1465H9.08789C8.57227 28.1465 8.18555 27.7598 8.05664 27.3086L7.54102 24.666H5.47852C4.96289 24.666 4.44727 24.2148 4.44727 23.6348C4.44727 23.1191 4.96289 22.6035 5.47852 22.6035Z" fill="var(--text-primary)"/>
                </svg>
            </div>
            <div class="rack-label" id="rackLabel">RACK</div>
        </div>
        <div class="completion-buttons" id="completionButtons">
            <button class="completion-btn active" id="bitMoreBtn">A bit more</button>
            <button class="completion-btn" id="keepWarmBtn">Keep warm</button>
        </div>
            </div>
        </div>
    </div>
    
    <button class="debug-toggle" onclick="toggleDebug()" id="debugToggle">Open animation controls</button>
    
    <div class="debug-panel" id="debugPanel">
        <h3>Debug Controls</h3>
        
        <div class="debug-control">
            <label>Phase B Tick Mode:</label>
            <select id="tickModeSelect">
                <option value="wrap">Wrap mode (72 ticks, 4 laps)</option>
                <option value="15min">15-min ticks (285 total)</option>
                <option value="hourly">Hourly ticks (72 total)</option>
            </select>
        </div>
        
        <div class="debug-control">
            <label>Enable Preheat:</label>
            <select id="preheatSelect">
                <option value="true">Enabled</option>
                <option value="false">Disabled</option>
            </select>
        </div>
        
        <div class="debug-control">
            <label>Gradient Color Mode:</label>
            <select id="gradientColorSelect">
                <option value="standard">Standard Colors</option>
                <option value="gradient">White-to-Gray Gradient</option>
                <option value="seamless" selected>Seamless Gradient (20% trail)</option>
            </select>
        </div>
        
        <div class="debug-control">
            <label>Ring Gap (degrees):</label>
            <input type="range" id="gapAngle" min="0" max="30" step="1" value="20">
            <div class="debug-value" id="gapAngleValue">20°</div>
        </div>
        
        <div class="debug-control">
            <label>Enable Tick Scaling:</label>
            <select id="enableScalingSelect">
                <option value="false">Disabled</option>
                <option value="true">Enabled</option>
            </select>
        </div>
        
        <div class="debug-control scaling-control">
            <label>Current Tick Length:</label>
            <input type="range" id="currentLength" min="1.5" max="4" step="0.1" value="3.0">
            <div class="debug-value" id="currentLengthValue">3.0x</div>
        </div>
        
        <div class="debug-control scaling-control">
            <label>Adjacent Falloff %:</label>
            <input type="range" id="adjacentFalloff" min="10" max="50" step="5" value="25">
            <div class="debug-value" id="adjacentFalloffValue">25%</div>
        </div>
        
        <div class="debug-control scaling-control">
            <label>Affected Radius %:</label>
            <input type="range" id="radiusPercent" min="5" max="20" step="1" value="10">
            <div class="debug-value" id="radiusPercentValue">10%</div>
        </div>
        
        <div class="debug-control scaling-control">
            <label>Auto Reset Scaling:</label>
            <select id="autoResetSelect">
                <option value="true">Enabled</option>
                <option value="false">Disabled</option>
            </select>
        </div>
        
        <div class="debug-control scaling-control">
            <label>Reset Delay (seconds):</label>
            <input type="number" id="resetDelay" min="0.5" max="10" step="0.1" value="0.5" style="width: 100%; padding: 4px; background: #555; color: white; border: 1px solid #666; border-radius: 3px;">
            <div class="debug-value" id="resetDelayValue">0.5s</div>
        </div>
        
        <div class="debug-control scaling-control">
            <label>Tick Alignment:</label>
            <select id="alignmentSelect">
                <option value="center">Centered</option>
                <option value="inward">Inward</option>
                <option value="outward">Outward</option>
            </select>
        </div>
        
        <div class="debug-control scaling-control">
            <label>Falloff Curve:</label>
            <select id="curveSelect">
                <option value="easeIn">Ease In</option>
                <option value="linear">Linear</option>
                <option value="easeOut">Ease Out</option>
                <option value="sine">Sine Wave</option>
                <option value="exponential">Exponential</option>
            </select>
        </div>
        
        <div class="debug-control">
            <label>Temperature Tick Count:</label>
            <select id="tempTickCountSelect">
                <option value="36">36 ticks (5°F steps)</option>
                <option value="72" selected>72 ticks (2.5°F steps)</option>
            </select>
        </div>
        
        <div class="debug-control">
            <label>Flash Duration (ms):</label>
            <input type="number" id="flashDuration" min="50" max="500" step="25" value="150" style="width: 100%; padding: 4px; background: #555; color: white; border: 1px solid #666; border-radius: 3px;">
            <div class="debug-value" id="flashDurationValue">150ms</div>
        </div>
        
        <div class="debug-control">
            <label>Flash Count:</label>
            <input type="number" id="flashCount" min="1" max="10" step="1" value="3" style="width: 100%; padding: 4px; background: #555; color: white; border: 1px solid #666; border-radius: 3px;">
            <div class="debug-value" id="flashCountValue">3 flashes</div>
        </div>
        
    </div>
    
    <div class="instructions">
        Instructions: <strong>P</strong> to turn right • <strong>O</strong> to turn left • <strong>Q</strong> to press in • <strong>1</strong> to start • <strong>R</strong> to restart
    </div>

    <script>
        const BASE_GRAY = '#434343';
        
        class CircularTimeDial {
            constructor() {
                this.canvas = document.getElementById('dial');
                this.ctx = this.canvas.getContext('2d');
                this.tempDisplay = document.getElementById('tempDisplay');
                this.timeDisplayMain = document.getElementById('timeDisplayMain');
                this.modeLabel = document.getElementById('modeLabel');
                this.cookingStatus = document.getElementById('cookingStatus');
                this.completionButtons = document.getElementById('completionButtons');
                this.bitMoreBtn = document.getElementById('bitMoreBtn');
                this.keepWarmBtn = document.getElementById('keepWarmBtn');
                
                this.totalMinutes = 10; // Start with 10 minutes
                this.maxMinutes = 72 * 60;
                
                this.temperature = 400; // Start with 400°F
                this.minTemp = 300;
                this.maxTemp = 480;
                
                this.tempMode = true; // Start in temperature mode
                
                this.centerX = 160;
                this.centerY = 160;
                this.radius = 136;
                
                // Timer for scaling reset
                this.lastActionTime = Date.now();
                this.scalingActive = false;
                
                // Animation properties
                this.animationDuration = 300; // ms
                this.animationStartTime = null;
                this.animatingToState = null; // 'active' or 'inactive'
                this.previousMultipliers = new Map(); // Store previous multipliers for smooth transitions
                
                // Ring fill animation properties
                this.ringFillAnimation = false;
                this.ringFillStartTime = null;
                this.ringFillDuration = 800; // ms - longer for smoother fill
                
                // Countdown mode properties
                this.countdownMode = false;
                this.countdownStartTime = null;
                this.countdownDuration = 0; // in seconds
                this.colonBlinkState = true;
                this.preheatPhase = false;
                this.preheatFlashState = true;
                
                // Completion state properties
                this.cookingComplete = false;
                this.selectedButton = 0; // 0 = "A bit more", 1 = "Keep warm"
                
                // Flash animation properties
                this.isFlashing = false;
                this.flashStartTime = null;
                this.flashCount = 0;
                this.flashVisible = true;
                this.hasFlashedAtBoundary = false;
                
                // Debug settings
                this.debugSettings = {
                    scalingEnabled: false,
                    gradientColorMode: 'seamless', // 'standard', 'gradient', 'seamless'
                    currentLength: 3.0,
                    adjacentFalloff: 25, // Percentage falloff from current
                    radiusPercent: 10,
                    alignment: 'center',
                    curve: 'easeIn',
                    tickMode: 'wrap',
                    autoReset: true,
                    resetDelay: 0.5,
                    gapAngle: 20, // Gap angle in degrees
                    preheatEnabled: true,
                    tempTickCount: 72, // Number of temperature ticks
                    flashDuration: 150, // Flash duration in ms
                    flashCount: 3 // Number of flashes
                };
                
                this.setupEventListeners();
                this.setupDebugControls();
                this.startUpdateLoop();
                this.render();
            }
            
            setupEventListeners() {
                document.addEventListener('keydown', (e) => {
                    const key = e.key.toLowerCase();
                    if (key === 'p') {
                        if (this.cookingComplete) {
                            this.navigateButtons(1); // Next button
                        } else {
                            this.increaseValue();
                        }
                    } else if (key === 'o') {
                        if (this.cookingComplete) {
                            this.navigateButtons(-1); // Previous button
                        } else {
                            this.decreaseValue();
                        }
                    } else if (key === 'r') {
                        this.restart();
                    } else if (key === 'q') {
                        this.toggleMode();
                    } else if (key === '1') {
                        this.startCooking();
                    }
                });
            }
            
            setupDebugControls() {
                // Enable Scaling Control
                const enableScalingSelect = document.getElementById('enableScalingSelect');
                enableScalingSelect.addEventListener('change', (e) => {
                    this.debugSettings.scalingEnabled = e.target.value === 'true';
                    this.toggleScalingControls();
                    this.render();
                });
                
                // Gradient Color Mode Control
                const gradientColorSelect = document.getElementById('gradientColorSelect');
                gradientColorSelect.addEventListener('change', (e) => {
                    this.debugSettings.gradientColorMode = e.target.value;
                    this.render();
                });
                
                // Current Length
                const currentLengthSlider = document.getElementById('currentLength');
                const currentLengthValue = document.getElementById('currentLengthValue');
                currentLengthSlider.addEventListener('input', (e) => {
                    this.debugSettings.currentLength = parseFloat(e.target.value);
                    currentLengthValue.textContent = `${this.debugSettings.currentLength}x`;
                    this.render();
                });
                
                // Adjacent Falloff
                const adjacentFalloffSlider = document.getElementById('adjacentFalloff');
                const adjacentFalloffValue = document.getElementById('adjacentFalloffValue');
                adjacentFalloffSlider.addEventListener('input', (e) => {
                    this.debugSettings.adjacentFalloff = parseInt(e.target.value);
                    adjacentFalloffValue.textContent = `${this.debugSettings.adjacentFalloff}%`;
                    this.render();
                });
                
                // Radius Percent
                const radiusPercentSlider = document.getElementById('radiusPercent');
                const radiusPercentValue = document.getElementById('radiusPercentValue');
                radiusPercentSlider.addEventListener('input', (e) => {
                    this.debugSettings.radiusPercent = parseInt(e.target.value);
                    radiusPercentValue.textContent = `${this.debugSettings.radiusPercent}%`;
                    this.render();
                });
                
                // Alignment Dropdown
                const alignmentSelect = document.getElementById('alignmentSelect');
                alignmentSelect.addEventListener('change', (e) => {
                    this.debugSettings.alignment = e.target.value;
                    this.render();
                });
                
                // Curve Dropdown
                const curveSelect = document.getElementById('curveSelect');
                curveSelect.addEventListener('change', (e) => {
                    this.debugSettings.curve = e.target.value;
                    this.render();
                });
                
                // Tick Mode Dropdown
                const tickModeSelect = document.getElementById('tickModeSelect');
                tickModeSelect.addEventListener('change', (e) => {
                    this.debugSettings.tickMode = e.target.value;
                    this.render();
                });
                
                // Gap Angle Control
                const gapAngleSlider = document.getElementById('gapAngle');
                const gapAngleValue = document.getElementById('gapAngleValue');
                gapAngleSlider.addEventListener('input', (e) => {
                    this.debugSettings.gapAngle = parseInt(e.target.value);
                    gapAngleValue.textContent = `${this.debugSettings.gapAngle}°`;
                    this.render();
                });
                
                // Preheat Control
                const preheatSelect = document.getElementById('preheatSelect');
                preheatSelect.addEventListener('change', (e) => {
                    this.debugSettings.preheatEnabled = e.target.value === 'true';
                    this.render();
                });
                
                // Auto Reset Dropdown
                const autoResetSelect = document.getElementById('autoResetSelect');
                autoResetSelect.addEventListener('change', (e) => {
                    this.debugSettings.autoReset = e.target.value === 'true';
                    this.render();
                });
                
                // Reset Delay Input
                const resetDelayInput = document.getElementById('resetDelay');
                const resetDelayValue = document.getElementById('resetDelayValue');
                resetDelayInput.addEventListener('input', (e) => {
                    this.debugSettings.resetDelay = parseFloat(e.target.value);
                    resetDelayValue.textContent = `${this.debugSettings.resetDelay}s`;
                });
                
                // Temperature Tick Count Control
                const tempTickCountSelect = document.getElementById('tempTickCountSelect');
                tempTickCountSelect.addEventListener('change', (e) => {
                    this.debugSettings.tempTickCount = parseInt(e.target.value);
                    this.render();
                });
                
                // Flash Duration Control
                const flashDurationInput = document.getElementById('flashDuration');
                const flashDurationValue = document.getElementById('flashDurationValue');
                flashDurationInput.addEventListener('input', (e) => {
                    this.debugSettings.flashDuration = parseInt(e.target.value);
                    flashDurationValue.textContent = `${this.debugSettings.flashDuration}ms`;
                });
                
                // Flash Count Control
                const flashCountInput = document.getElementById('flashCount');
                const flashCountValue = document.getElementById('flashCountValue');
                flashCountInput.addEventListener('input', (e) => {
                    this.debugSettings.flashCount = parseInt(e.target.value);
                    flashCountValue.textContent = `${this.debugSettings.flashCount} flashes`;
                });
                
                // Initialize scaling controls visibility
                this.toggleScalingControls();
            }
            
            toggleScalingControls() {
                const scalingControls = document.querySelectorAll('.scaling-control');
                scalingControls.forEach(control => {
                    if (this.debugSettings.scalingEnabled) {
                        control.classList.remove('hidden');
                    } else {
                        control.classList.add('hidden');
                    }
                });
            }
            
            increaseValue() {
                if (this.countdownMode) return;
                
                if (this.tempMode) {
                    if (this.temperature >= this.maxTemp) {
                        // Only trigger flash once per boundary hit
                        if (!this.hasFlashedAtBoundary && !this.isFlashing) {
                            this.startFlashAnimation();
                            this.hasFlashedAtBoundary = true;
                        }
                        return;
                    }
                    
                    // Reset flash boundary flag when moving away from boundary
                    this.hasFlashedAtBoundary = false;
                    
                    this.lastActionTime = Date.now();
                    if (!this.scalingActive) {
                        this.startScalingAnimation(true);
                    }
                    this.scalingActive = true;
                    
                    // Always increment by 5°F regardless of tick count
                    this.temperature = Math.min(this.temperature + 5, this.maxTemp);
                } else {
                    this.increaseTime();
                }
                this.render();
            }
            
            decreaseValue() {
                if (this.countdownMode) return;
                
                if (this.tempMode) {
                    if (this.temperature <= this.minTemp) {
                        // Only trigger flash once per boundary hit
                        if (!this.hasFlashedAtBoundary && !this.isFlashing) {
                            this.startFlashAnimation();
                            this.hasFlashedAtBoundary = true;
                        }
                        return;
                    }
                    
                    // Reset flash boundary flag when moving away from boundary
                    this.hasFlashedAtBoundary = false;
                    
                    this.lastActionTime = Date.now();
                    if (!this.scalingActive) {
                        this.startScalingAnimation(true);
                    }
                    this.scalingActive = true;
                    
                    // Always decrement by 5°F regardless of tick count
                    this.temperature = Math.max(this.temperature - 5, this.minTemp);
                } else {
                    this.decreaseTime();
                }
                this.render();
            }
            
            toggleMode() {
                if (this.countdownMode) return;
                this.tempMode = !this.tempMode;
                this.render();
            }
            
            startCooking() {
                if (this.countdownMode) return;
                this.startRingFillAnimation();
            }
            
            startScalingAnimation(toActive) {
                this.animationStartTime = Date.now();
                this.animatingToState = toActive ? 'active' : 'inactive';
                this.animateTransition();
            }
            
            startFlashAnimation() {
                this.isFlashing = true;
                this.flashStartTime = Date.now();
                this.flashCount = 0;
                this.flashVisible = true;
                this.animateFlash();
            }
            
            animateFlash() {
                if (!this.isFlashing) return;
                
                const currentTime = Date.now();
                const elapsed = currentTime - this.flashStartTime;
                const flashDuration = this.debugSettings.flashDuration; // ms per flash (on/off cycle)
                const totalFlashes = this.debugSettings.flashCount;
                
                // Calculate current flash cycle
                const flashCycle = Math.floor(elapsed / flashDuration);
                
                if (flashCycle >= totalFlashes * 2) {
                    // Animation complete
                    this.isFlashing = false;
                    this.flashVisible = true;
                    this.render();
                    return;
                }
                
                // Toggle visibility every flash duration
                this.flashVisible = (flashCycle % 2 === 0);
                this.render();
                
                requestAnimationFrame(() => this.animateFlash());
            }
            
            animateTransition() {
                const currentTime = Date.now();
                const elapsed = currentTime - this.animationStartTime;
                const progress = Math.min(elapsed / this.animationDuration, 1);
                
                // Ease function
                const easeProgress = 1 - Math.pow(1 - progress, 3);
                
                this.animationProgress = easeProgress;
                this.render();
                
                if (progress < 1) {
                    requestAnimationFrame(() => this.animateTransition());
                } else {
                    this.animationStartTime = null;
                    this.animatingToState = null;
                    this.animationProgress = null;
                }
            }
            
            startUpdateLoop() {
                setInterval(() => {
                    if (!this.debugSettings.autoReset) return;
                    
                    const timeSinceLastAction = Date.now() - this.lastActionTime;
                    const wasScalingActive = this.scalingActive;
                    
                    if (timeSinceLastAction > (this.debugSettings.resetDelay * 1000)) {
                        if (this.scalingActive) {
                            this.startScalingAnimation(false);
                        }
                        this.scalingActive = false;
                    }
                }, 100); // Check every 100ms
                
                // Countdown update loop
                setInterval(() => {
                    if (this.countdownMode) {
                        this.updateCountdown();
                    }
                }, 100); // Update countdown every 100ms
                
                // Preheat flash loop
                setInterval(() => {
                    if (this.countdownMode && this.preheatPhase) {
                        this.preheatFlashState = !this.preheatFlashState;
                        this.render();
                    }
                }, 600); // Flash every 600ms
            }
            
            formatTime() {
                if (this.totalMinutes < 60) {
                    // Phase A: Show minutes as M:00 (1:00, 2:00, etc.)
                    return `${this.totalMinutes}:00`;
                } else {
                    // Phase B: Show hours and minutes as H:MM
                    const hours = Math.floor(this.totalMinutes / 60);
                    const minutes = this.totalMinutes % 60;
                    return `${hours}:${minutes.toString().padStart(2, '0')}`;
                }
            }
            
            render() {
                // Clear canvas
                this.ctx.fillStyle = 'black';
                this.ctx.fillRect(0, 0, 320, 320);
                
                if (this.cookingComplete) {
                    this.renderCompletionMode();
                } else if (this.ringFillAnimation) {
                    this.renderRingFillAnimation();
                } else if (this.countdownMode) {
                    this.renderCountdownMode();
                } else {
                    if (this.tempMode) {
                        this.renderTemperatureMode();
                    } else {
                        if (this.totalMinutes < 60) {
                            this.renderPhaseA();
                        } else {
                            this.renderPhaseB();
                        }
                    }
                }
                
                // Update display
                if (this.cookingComplete) {
                    this.updateCompletionDisplay();
                } else if (this.ringFillAnimation) {
                    this.updateStartingDisplay();
                } else if (this.countdownMode) {
                    this.updateCountdownDisplay();
                } else {
                    this.updateSetupDisplay();
                }
            }
            
            updateSetupDisplay() {
                // Hide cooking status and completion buttons during setup
                this.cookingStatus.style.display = 'none';
                this.completionButtons.style.display = 'none';
                
                // Determine label text based on phase
                const labelText = this.totalMinutes < 60 ? 'MIN - SEC' : 'HR - MIN';
                
                if (this.tempMode) {
                    // Temperature mode: temperature is active, time is inactive
                    this.tempDisplay.querySelector('.temp-number').textContent = this.temperature;
                    this.tempDisplay.className = 'temp-display active';
                    // Apply flash visibility to temperature display
                    this.tempDisplay.style.opacity = (this.isFlashing && !this.flashVisible) ? '0' : '1';
                    
                    this.timeDisplayMain.textContent = this.formatTime();
                    this.timeDisplayMain.className = 'time-display-main inactive';
                    this.modeLabel.textContent = labelText;
                    this.modeLabel.style.color = 'var(--text-tertiary)';
                    this.modeLabel.style.opacity = 1.0;
                } else {
                    // Time mode: time is active, temperature is inactive
                    this.tempDisplay.querySelector('.temp-number').textContent = this.temperature;
                    this.tempDisplay.className = 'temp-display inactive';
                    this.timeDisplayMain.textContent = this.formatTime();
                    this.timeDisplayMain.className = 'time-display-main active';
                    // Apply flash visibility to time display
                    this.timeDisplayMain.style.opacity = (this.isFlashing && !this.flashVisible) ? '0' : '1';
                    
                    this.modeLabel.textContent = labelText;
                    this.modeLabel.style.color = 'var(--text-primary)';
                    this.modeLabel.style.opacity = 1.0;
                }
            }
            
            updateStartingDisplay() {
                // Hide completion buttons during starting
                this.completionButtons.style.display = 'none';
                // Show cooking status during starting animation
                this.cookingStatus.style.display = 'block';
                this.cookingStatus.style.opacity = 1.0;
                this.cookingStatus.textContent = this.debugSettings.preheatEnabled ? 'Preheating...' : 'Actively cooking';
                
                this.tempDisplay.querySelector('.temp-number').textContent = this.temperature;
                this.tempDisplay.className = 'temp-display inactive';
                this.timeDisplayMain.textContent = this.formatTime();
                this.timeDisplayMain.className = 'time-display-main active';
                
                // Show appropriate time label below
                this.modeLabel.textContent = this.totalMinutes < 60 ? 'MIN - SEC' : 'HR - MIN';
                this.modeLabel.style.color = 'var(--text-tertiary)';
                this.modeLabel.style.opacity = 1.0;
            }
            
            updateCountdownDisplay() {
                // Hide completion buttons during cooking
                this.completionButtons.style.display = 'none';
                // Show cooking status above circle
                this.cookingStatus.style.display = 'block';
                
                if (this.preheatPhase && this.debugSettings.preheatEnabled) {
                    // During preheat: show temperature and time set
                    this.tempDisplay.querySelector('.temp-number').textContent = this.temperature;
                    this.tempDisplay.className = 'temp-display inactive';
                    this.timeDisplayMain.textContent = this.formatTime();
                    this.timeDisplayMain.className = 'time-display-main active';
                    
                    // Flash the cooking status above circle
                    const labelOpacity = this.preheatFlashState ? 1.0 : 0.25;
                    this.cookingStatus.style.opacity = labelOpacity;
                    this.cookingStatus.textContent = 'Preheating...';
                    
                    // Keep original label below (HR-MIN since we're in phase B during cooking)
                    this.modeLabel.textContent = this.totalMinutes < 60 ? 'MIN - SEC' : 'HR - MIN';
                    this.modeLabel.style.color = 'var(--text-tertiary)';
                    this.modeLabel.style.opacity = 1.0;
                } else {
                    // During cooking: show countdown with temperature
                    this.tempDisplay.querySelector('.temp-number').textContent = this.temperature;
                    this.tempDisplay.className = 'temp-display inactive';
                    const { minutes, seconds } = this.getCurrentCountdownTime();
                    
                    // Format time like 1:15 for 1hr 15min, 59:00 for 59min
                    const totalMinutesLeft = minutes;
                    const isUnderOneHour = totalMinutesLeft < 60;
                    
                    if (isUnderOneHour) {
                        // Show as MM:SS format for under 1 hour
                        this.timeDisplayMain.textContent = `${totalMinutesLeft.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                    } else {
                        // Show as H:MM format for 1+ hours
                        const hours = Math.floor(totalMinutesLeft / 60);
                        const mins = totalMinutesLeft % 60;
                        this.timeDisplayMain.textContent = `${hours}:${mins.toString().padStart(2, '0')}`;
                    }
                    
                    this.timeDisplayMain.className = 'time-display-main active';
                    
                    // Show "Actively cooking" above circle
                    this.cookingStatus.style.opacity = 1.0;
                    this.cookingStatus.textContent = 'Actively cooking';
                    
                    // Show appropriate label below based on time remaining
                    this.modeLabel.textContent = isUnderOneHour ? 'MIN - SEC' : 'HR - MIN';
                    this.modeLabel.style.color = 'var(--text-tertiary)';
                    this.modeLabel.style.opacity = 1.0;
                }
            }
            
            renderTemperatureMode() {
                // Calculate temperature progress and current tick based on configurable tick count
                const tempRange = this.maxTemp - this.minTemp; // 180 degrees
                const totalTempTicks = this.debugSettings.tempTickCount + 1; // Add 1 for endpoint
                const tempIncrement = tempRange / this.debugSettings.tempTickCount; // Calculate dynamic increment
                const currentTempTick = Math.round((this.temperature - this.minTemp) / tempIncrement); // Round to nearest tick
                const filledTempTicks = currentTempTick + 1; // Include current tick in filled count
                
                for (let i = 0; i < totalTempTicks; i++) {
                    const angle = (i * (360 / totalTempTicks) - 90) * Math.PI / 180;
                    const isFilled = i < filledTempTicks;
                    const isCurrent = i === currentTempTick;
                    
                    // Calculate proximity to current tick for gradual sizing
                    const lengthMultiplier = this.getTickLengthMultiplier(i, currentTempTick, totalTempTicks);
                    
                    this.drawTick(angle, isFilled, isCurrent, false, lengthMultiplier, false, 0, i, currentTempTick, totalTempTicks);
                }
            }
            
            renderRingFillAnimation() {
                const elapsed = Date.now() - this.ringFillStartTime;
                const progress = Math.min(elapsed / this.ringFillDuration, 1);
                
                // Ease-out animation for smoother filling
                const easeProgress = 1 - Math.pow(1 - progress, 2);
                
                // Calculate gap and segments like in countdown mode
                const mainGapAngle = (this.debugSettings.gapAngle * Math.PI) / 180;
                const preheatGapAngle = this.debugSettings.preheatEnabled ? (10 * Math.PI) / 180 : 0;
                const totalGapsAngle = mainGapAngle + preheatGapAngle;
                const availableAngle = 2 * Math.PI - totalGapsAngle;
                
                const topCenter = -Math.PI / 2;
                
                if (this.debugSettings.preheatEnabled) {
                    const preheatPercentage = 0.25;
                    const cookingPercentage = 0.75;
                    const preheatAngle = availableAngle * preheatPercentage;
                    const cookingAngle = availableAngle * cookingPercentage;
                    
                    const preheatStartAngle = topCenter - mainGapAngle / 2;
                    const preheatEndAngle = preheatStartAngle - preheatAngle;
                    const cookingStartAngle = preheatEndAngle - preheatGapAngle;
                    const cookingEndAngle = cookingStartAngle - cookingAngle;
                    
                    // Draw background segments
                    this.ctx.beginPath();
                    this.ctx.arc(this.centerX, this.centerY, this.radius, preheatEndAngle, preheatStartAngle);
                    this.ctx.strokeStyle = '#5a060a';
                    this.ctx.lineWidth = 20;
                    this.ctx.lineCap = 'round';
                    this.ctx.stroke();
                    
                    this.ctx.beginPath();
                    this.ctx.arc(this.centerX, this.centerY, this.radius, cookingEndAngle, cookingStartAngle);
                    this.ctx.strokeStyle = '#5a060a';
                    this.ctx.lineWidth = 20;
                    this.ctx.lineCap = 'round';
                    this.ctx.stroke();
                    
                    // Draw animated fill
                    const totalFillAngle = preheatAngle + cookingAngle;
                    const currentFillAngle = totalFillAngle * easeProgress;
                    
                    if (currentFillAngle > 0) {
                        if (currentFillAngle <= preheatAngle) {
                            // Filling preheat segment
                            const fillEndAngle = preheatStartAngle - currentFillAngle;
                            this.ctx.beginPath();
                            this.ctx.arc(this.centerX, this.centerY, this.radius, fillEndAngle, preheatStartAngle);
                            this.ctx.strokeStyle = '#FA4947';
                            this.ctx.lineWidth = 20;
                            this.ctx.lineCap = 'round';
                            this.ctx.stroke();
                        } else {
                            // Preheat full, filling cooking segment
                            this.ctx.beginPath();
                            this.ctx.arc(this.centerX, this.centerY, this.radius, preheatEndAngle, preheatStartAngle);
                            this.ctx.strokeStyle = '#FA4947';
                            this.ctx.lineWidth = 20;
                            this.ctx.lineCap = 'round';
                            this.ctx.stroke();
                            
                            const cookingFillAngle = currentFillAngle - preheatAngle;
                            const cookingFillEndAngle = cookingStartAngle - cookingFillAngle;
                            this.ctx.beginPath();
                            this.ctx.arc(this.centerX, this.centerY, this.radius, cookingFillEndAngle, cookingStartAngle);
                            this.ctx.strokeStyle = '#FA4947';
                            this.ctx.lineWidth = 20;
                            this.ctx.lineCap = 'round';
                            this.ctx.stroke();
                        }
                    }
                } else {
                    // No preheat: simple fill animation
                    const startAngle = topCenter + mainGapAngle / 2;
                    const endAngle = startAngle + availableAngle;
                    
                    this.ctx.beginPath();
                    this.ctx.arc(this.centerX, this.centerY, this.radius, startAngle, endAngle);
                    this.ctx.strokeStyle = '#5a060a';
                    this.ctx.lineWidth = 20;
                    this.ctx.lineCap = 'round';
                    this.ctx.stroke();
                    
                    if (easeProgress > 0) {
                        const fillAngle = availableAngle * easeProgress;
                        const fillEndAngle = startAngle + fillAngle;
                        
                        this.ctx.beginPath();
                        this.ctx.arc(this.centerX, this.centerY, this.radius, startAngle, fillEndAngle);
                        this.ctx.strokeStyle = '#FA4947';
                        this.ctx.lineWidth = 20;
                        this.ctx.lineCap = 'round';
                        this.ctx.stroke();
                    }
                }
            }
            
            renderCountdownMode() {
                if (this.countdownDuration === 0) return;
                
                const elapsed = this.countdownStartTime ? (Date.now() - this.countdownStartTime) / 1000 : 0;
                
                // Calculate gap size (in radians) from debug settings
                const mainGapAngle = (this.debugSettings.gapAngle * Math.PI) / 180;
                const preheatGapAngle = this.debugSettings.preheatEnabled ? (10 * Math.PI) / 180 : 0; // 10% gap after preheat
                const totalGapsAngle = mainGapAngle + preheatGapAngle;
                const availableAngle = 2 * Math.PI - totalGapsAngle;
                
                // Calculate preheat and cooking segments
                const preheatPercentage = this.debugSettings.preheatEnabled ? 0.25 : 0; // 25% for preheat
                const cookingPercentage = 1 - preheatPercentage;
                
                const preheatAngle = availableAngle * preheatPercentage;
                const cookingAngle = availableAngle * cookingPercentage;
                
                // Main gap is centered at top: preheat starts after gap and goes counter-clockwise (left)
                const topCenter = -Math.PI / 2;
                const preheatStartAngle = topCenter - mainGapAngle / 2; // Start before main gap (left side)
                const preheatEndAngle = preheatStartAngle - preheatAngle; // Go further counter-clockwise (left)
                
                // Secondary gap and cooking segment start
                const cookingStartAngle = preheatEndAngle - preheatGapAngle;
                const cookingEndAngle = cookingStartAngle - cookingAngle;
                
                if (this.debugSettings.preheatEnabled) {
                    // Draw preheat segment background (dark red)
                    this.ctx.beginPath();
                    this.ctx.arc(this.centerX, this.centerY, this.radius, preheatEndAngle, preheatStartAngle);
                    this.ctx.strokeStyle = '#5a060a';
                    this.ctx.lineWidth = 20;
                    this.ctx.lineCap = 'round';
                    this.ctx.stroke();
                    
                    // Draw cooking segment background (dark red)
                    this.ctx.beginPath();
                    this.ctx.arc(this.centerX, this.centerY, this.radius, cookingEndAngle, cookingStartAngle);
                    this.ctx.strokeStyle = '#5a060a';
                    this.ctx.lineWidth = 20;
                    this.ctx.lineCap = 'round';
                    this.ctx.stroke();
                    
                    if (this.preheatPhase) {
                        // During preheat: unfill preheat segment CLOCKWISE (from left to right, like in the image)
                        const preheatProgress = Math.min(elapsed / 10, 1); // 10 seconds preheat
                        const remainingPreheatProgress = 1 - preheatProgress; // How much is left
                        const remainingPreheatAngle = preheatAngle * remainingPreheatProgress;
                        
                        if (remainingPreheatAngle > 0) {
                            // Draw from the END, keeping the right portion (near the gap)
                            const currentPreheatStartAngle = preheatEndAngle + remainingPreheatAngle;
                            this.ctx.beginPath();
                            this.ctx.arc(this.centerX, this.centerY, this.radius, preheatEndAngle, currentPreheatStartAngle);
                            this.ctx.strokeStyle = '#FA4947';
                            this.ctx.lineWidth = 20;
                            this.ctx.lineCap = 'round';
                            this.ctx.stroke();
                        }
                        
                        // Keep cooking segment full during preheat
                        this.ctx.beginPath();
                        this.ctx.arc(this.centerX, this.centerY, this.radius, cookingEndAngle, cookingStartAngle);
                        this.ctx.strokeStyle = '#FA4947';
                        this.ctx.lineWidth = 20;
                        this.ctx.lineCap = 'round';
                        this.ctx.stroke();
                    } else {
                        // During cooking: cooking segment unfills CLOCKWISE (same direction as preheat)
                        const cookingProgress = 1 - Math.min(elapsed / this.countdownDuration, 1);
                        const remainingCookingAngle = cookingAngle * cookingProgress;
                        
                        if (remainingCookingAngle > 0) {
                            // Draw from the END, keeping the right portion (clockwise unfilling)
                            const currentCookingStartAngle = cookingEndAngle + remainingCookingAngle;
                            this.ctx.beginPath();
                            this.ctx.arc(this.centerX, this.centerY, this.radius, cookingEndAngle, currentCookingStartAngle);
                            this.ctx.strokeStyle = '#FA4947';
                            this.ctx.lineWidth = 20;
                            this.ctx.lineCap = 'round';
                            this.ctx.stroke();
                        }
                    }
                } else {
                    // No preheat: standard behavior - starts from top and goes clockwise
                    const remaining = Math.max(0, this.countdownDuration - elapsed);
                    const progress = 1 - Math.min(elapsed / this.countdownDuration, 1);
                    
                    const startAngle = topCenter + mainGapAngle / 2;
                    const endAngle = startAngle + availableAngle;
                    
                    // Draw dark red background ring
                    this.ctx.beginPath();
                    this.ctx.arc(this.centerX, this.centerY, this.radius, startAngle, endAngle);
                    this.ctx.strokeStyle = '#5a060a';
                    this.ctx.lineWidth = 20;
                    this.ctx.lineCap = 'round';
                    this.ctx.stroke();
                    
                    // Draw bright red progress ring
                    if (progress > 0) {
                        const progressAngle = progress * availableAngle;
                        const progressEndAngle = startAngle + progressAngle;
                        
                        this.ctx.beginPath();
                        this.ctx.arc(this.centerX, this.centerY, this.radius, startAngle, progressEndAngle);
                        this.ctx.strokeStyle = '#FA4947';
                        this.ctx.lineWidth = 20;
                        this.ctx.lineCap = 'round';
                        this.ctx.stroke();
                    }
                }
            }
            
            renderPhaseA() {
                const totalTicks = 59; // 59 ticks for minutes 1-59
                const filledTicks = Math.max(1, Math.min(this.totalMinutes, 59)); // Always at least 1 tick filled
                const currentTickIndex = filledTicks - 1;
                
                for (let i = 0; i < totalTicks; i++) {
                    const angle = (i * (360 / totalTicks) - 90) * Math.PI / 180;
                    const isFilled = i < filledTicks;
                    const isCurrent = i === currentTickIndex;
                    
                    // Calculate proximity to current tick for gradual sizing
                    const lengthMultiplier = this.getTickLengthMultiplier(i, currentTickIndex, totalTicks);
                    
                    this.drawTick(angle, isFilled, isCurrent, false, lengthMultiplier, false, 0, i, currentTickIndex, totalTicks);
                }
            }
            
            renderPhaseB() {
                if (this.debugSettings.tickMode === 'hourly') {
                    this.renderPhaseBHourly();
                } else if (this.debugSettings.tickMode === 'wrap') {
                    this.renderPhaseBWrap();
                } else {
                    this.renderPhaseB15Min();
                }
            }
            
            renderPhaseB15Min() {
                const totalTicks = 285; // 71 hours * 4 + 1 for 1:00
                const minutesInPhaseB = this.totalMinutes - 60;
                const ticksInPhaseB = Math.max(1, Math.floor(minutesInPhaseB / 15) + 1); // +1 for 1:00 tick, always at least 1
                const currentTickIndex = ticksInPhaseB - 1;
                
                for (let i = 0; i < totalTicks; i++) {
                    const angle = (i * (360 / totalTicks) - 90) * Math.PI / 180;
                    const isFilled = i < ticksInPhaseB;
                    const isCurrent = i === currentTickIndex;
                    
                    const lengthMultiplier = this.getTickLengthMultiplier(i, currentTickIndex, totalTicks);
                    
                    this.drawTick(angle, isFilled, isCurrent, true, lengthMultiplier, false, 0, i, currentTickIndex, totalTicks);
                }
            }
            
            renderPhaseBWrap() {
                const totalTicks = 72; // 72 ticks around the circle
                const minutesInPhaseB = this.totalMinutes - 60;
                // Each increment is 15 minutes
                // At 60 min (1:00), we want the first tick filled
                // At 75 min (1:15), we want the second tick filled, etc.
                const incrementsCompleted = Math.floor(minutesInPhaseB / 15) + 1; // +1 to start with 1 tick at 1:00
                const currentLap = Math.floor((incrementsCompleted - 1) / 72); // Adjust for the +1
                const ticksInCurrentLap = ((incrementsCompleted - 1) % 72) + 1; // Always 1-72
                const currentTickIndex = ticksInCurrentLap - 1;

                for (let i = 0; i < totalTicks; i++) {
                    const angle = (i * (360 / totalTicks) - 90) * Math.PI / 180;
                    // Show filled ticks for current lap progress
                    const isFilled = i < ticksInCurrentLap;
                    // Show gray for completed laps
                    const showAsGray = currentLap > 0 && i >= ticksInCurrentLap;
                    const isCurrent = i === currentTickIndex;
                    const lengthMultiplier = this.getTickLengthMultiplier(i, currentTickIndex, totalTicks);
                    this.drawWrapTick(angle, isFilled, isCurrent, currentLap, lengthMultiplier, showAsGray, i, currentTickIndex, totalTicks);
                }
            }
            
            renderPhaseBHourly() {
                const totalTicks = 72; // One tick per hour
                const minutesInPhaseB = this.totalMinutes - 60;
                const hoursCompleted = Math.max(1, Math.floor(minutesInPhaseB / 60) + 1); // +1 for the 1:00 hour, always at least 1
                const currentTickIndex = hoursCompleted - 1;
                
                // Calculate progress within current hour for next tick animation
                const minutesInCurrentHour = minutesInPhaseB % 60;
                const hourProgress = minutesInCurrentHour / 60; // 0 to 1
                
                for (let i = 0; i < totalTicks; i++) {
                    const angle = (i * (360 / totalTicks) - 90) * Math.PI / 180;
                    const isFilled = i < hoursCompleted;
                    const isCurrent = i === currentTickIndex;
                    const isNext = i === currentTickIndex + 1 && currentTickIndex + 1 < totalTicks;
                    
                    const lengthMultiplier = this.getTickLengthMultiplier(i, currentTickIndex, totalTicks);
                    
                    this.drawTick(angle, isFilled, isCurrent, true, lengthMultiplier, isNext, hourProgress, i, currentTickIndex, totalTicks);
                }
            }
            
            restart() {
                // Reset all values to initial defaults
                this.totalMinutes = 10; // Start with 10 minutes
                this.temperature = 400; // Start with 400°F
                this.tempMode = true; // Start in temperature mode
                
                // Reset timer and scaling properties
                this.lastActionTime = Date.now();
                this.scalingActive = false;
                
                // Reset animation properties
                this.animationStartTime = null;
                this.animatingToState = null;
                this.animationProgress = null;
                this.previousMultipliers = new Map();
                
                // Reset ring fill animation properties
                this.ringFillAnimation = false;
                this.ringFillStartTime = null;
                
                // Reset countdown mode properties
                this.countdownMode = false;
                this.countdownStartTime = null;
                this.countdownDuration = 0;
                this.colonBlinkState = true;
                this.preheatPhase = false;
                this.preheatFlashState = true;
                
                // Reset completion state
                this.cookingComplete = false;
                this.selectedButton = 0;
                
                // Reset flash animation
                this.isFlashing = false;
                this.flashStartTime = null;
                this.flashCount = 0;
                this.flashVisible = true;
                this.hasFlashedAtBoundary = false;
                
                this.render();
            }
            
            navigateButtons(direction) {
                this.selectedButton = (this.selectedButton + direction + 2) % 2; // Keep in range 0-1
                this.updateButtonSelection();
            }
            
            updateButtonSelection() {
                this.bitMoreBtn.classList.toggle('active', this.selectedButton === 0);
                this.keepWarmBtn.classList.toggle('active', this.selectedButton === 1);
            }
            
            renderCompletionMode() {
                // Draw a full green circle
                this.ctx.beginPath();
                this.ctx.arc(this.centerX, this.centerY, this.radius, 0, 2 * Math.PI);
                this.ctx.strokeStyle = '#2BB671';
                this.ctx.lineWidth = 20;
                this.ctx.lineCap = 'round';
                this.ctx.stroke();
            }
            
            updateCompletionDisplay() {
                // Hide cooking status
                this.cookingStatus.style.display = 'none';
                
                // Show completion buttons
                this.completionButtons.style.display = 'flex';
                
                // Update display content
                this.tempDisplay.querySelector('.temp-number').textContent = this.temperature;
                this.tempDisplay.className = 'temp-display inactive';
                this.timeDisplayMain.textContent = '00:00';
                this.timeDisplayMain.className = 'time-display-main active';
                
                // Change label to "Enjoy"
                this.modeLabel.textContent = 'Enjoy';
                this.modeLabel.style.color = '#2BB671';
                this.modeLabel.style.opacity = 1.0;
                
                // Update button selection
                this.updateButtonSelection();
            }
            
            increaseTime() {
                if (this.totalMinutes >= this.maxMinutes) {
                    // Only trigger flash once per boundary hit
                    if (!this.hasFlashedAtBoundary && !this.isFlashing) {
                        this.startFlashAnimation();
                        this.hasFlashedAtBoundary = true;
                    }
                    return;
                }
                
                // Reset flash boundary flag when moving away from boundary
                this.hasFlashedAtBoundary = false;
                
                this.lastActionTime = Date.now();
                if (!this.scalingActive) {
                    this.startScalingAnimation(true);
                }
                this.scalingActive = true;
                
                if (this.totalMinutes < 60) {
                    this.totalMinutes += 1;
                } else {
                    this.totalMinutes = Math.min(this.totalMinutes + 15, this.maxMinutes);
                }
                
                this.render();
            }
            
            decreaseTime() {
                if (this.totalMinutes <= 1) {
                    // Only trigger flash once per boundary hit
                    if (!this.hasFlashedAtBoundary && !this.isFlashing) {
                        this.startFlashAnimation();
                        this.hasFlashedAtBoundary = true;
                    }
                    return;
                }
                
                // Reset flash boundary flag when moving away from boundary
                this.hasFlashedAtBoundary = false;
                
                this.lastActionTime = Date.now();
                if (!this.scalingActive) {
                    this.startScalingAnimation(true);
                }
                this.scalingActive = true;
                
                if (this.totalMinutes <= 60) {
                    this.totalMinutes = Math.max(this.totalMinutes - 1, 1); // Stop at 1 minute
                } else {
                    this.totalMinutes = Math.max(this.totalMinutes - 15, 60);
                    if (this.totalMinutes === 60) {
                        this.totalMinutes = 59;
                    }
                }
                
                this.render();
            }
            
            startRingFillAnimation() {
                this.ringFillAnimation = true;
                this.ringFillStartTime = Date.now();
                this.animateRingFill();
            }
            
            animateRingFill() {
                const currentTime = Date.now();
                const elapsed = currentTime - this.ringFillStartTime;
                const progress = Math.min(elapsed / this.ringFillDuration, 1);
                
                this.render();
                
                if (progress < 1) {
                    requestAnimationFrame(() => this.animateRingFill());
                } else {
                    // Animation complete, start actual countdown
                    this.ringFillAnimation = false;
                    this.countdownMode = true;
                    this.countdownDuration = this.totalMinutes * 60;
                    this.countdownStartTime = Date.now();
                    this.colonBlinkState = true;
                    this.preheatFlashState = true;
                    this.preheatPhase = this.debugSettings.preheatEnabled;
                    this.render();
                }
            }
            
            updateCountdown() {
                if (!this.countdownMode || this.countdownStartTime === null) return;
                
                const elapsed = (Date.now() - this.countdownStartTime) / 1000; // seconds
                
                // Handle preheat phase (10 seconds) - only if preheat is enabled
                if (this.preheatPhase && this.debugSettings.preheatEnabled && elapsed >= 10) {
                    this.preheatPhase = false;
                    this.countdownStartTime = Date.now(); // Reset timer for cooking phase
                    this.render();
                    return;
                }
                
                // Handle cooking phase (or immediate cooking if no preheat)
                if (!this.preheatPhase || !this.debugSettings.preheatEnabled) {
                    const remaining = Math.max(0, this.countdownDuration - elapsed);
                    
                    if (remaining <= 0) {
                        // Countdown finished
                        this.countdownMode = false;
                        this.cookingComplete = true;
                        this.totalMinutes = 0;
                    }
                }
                
                this.render();
            }
            
            getCurrentCountdownTime() {
                if (!this.countdownMode || this.countdownStartTime === null) {
                    return { minutes: 0, seconds: 0 };
                }
                
                const elapsed = (Date.now() - this.countdownStartTime) / 1000;
                const remaining = Math.max(0, this.countdownDuration - elapsed);
                
                const minutes = Math.floor(remaining / 60);
                const seconds = Math.floor(remaining % 60);
                
                return { minutes, seconds };
            }
            
            applyCurve(normalizedDistance) {
                // normalizedDistance is 0-1, where 0 is current tick, 1 is edge of affected radius
                switch (this.debugSettings.curve) {
                    case 'linear':
                        return 1 - normalizedDistance;
                    case 'easeOut':
                        return 1 - (normalizedDistance * normalizedDistance);
                    case 'easeIn':
                        return 1 - Math.sqrt(normalizedDistance);
                    case 'sine':
                        return Math.cos(normalizedDistance * Math.PI / 2);
                    case 'exponential':
                        return Math.pow(1 - normalizedDistance, 3);
                    default:
                        return 1 - normalizedDistance;
                }
            }
            
            getTickLengthMultiplier(tickIndex, currentTickIndex, totalTicks) {
                // If scaling is disabled, always return 1.0
                if (!this.debugSettings.scalingEnabled) return 1.0;
                
                if (currentTickIndex === -1) return 1.0; // No current tick
                
                // Calculate base multipliers for active state
                const affectedRadius = Math.floor(totalTicks * (this.debugSettings.radiusPercent / 100));
                let distance = Math.abs(tickIndex - currentTickIndex);
                const wrapDistance = totalTicks - distance;
                distance = Math.min(distance, wrapDistance);
                
                let activeMultiplier = 1.0;
                if (distance === 0) {
                    activeMultiplier = this.debugSettings.currentLength;
                } else if (distance <= affectedRadius) {
                    const falloffAmount = (this.debugSettings.currentLength - 1.0) * (this.debugSettings.adjacentFalloff / 100);
                    const adjacentLength = this.debugSettings.currentLength - falloffAmount;
                    const normalizedDistance = (distance - 1) / (affectedRadius - 1);
                    const curveValue = this.applyCurve(normalizedDistance);
                    const falloffRange = adjacentLength - 1.0;
                    activeMultiplier = 1.0 + (falloffRange * curveValue);
                }
                
                // Handle auto reset and animation states
                if (!this.debugSettings.autoReset) {
                    // No auto reset - use active multiplier if scaling is active, otherwise 1.0
                    return this.scalingActive ? activeMultiplier : 1.0;
                }
                
                // Auto reset is enabled
                if (!this.scalingActive && this.animationStartTime === null) {
                    return 1.0; // Inactive and not animating
                }
                
                if (this.scalingActive && this.animationStartTime === null) {
                    return activeMultiplier; // Active and not animating
                }
                
                // Currently animating
                if (this.animationStartTime !== null && this.animationProgress !== null) {
                    if (this.animatingToState === 'active') {
                        // Animating from 1.0 to activeMultiplier
                        return 1.0 + (activeMultiplier - 1.0) * this.animationProgress;
                    } else {
                        // Animating from activeMultiplier to 1.0
                        return activeMultiplier + (1.0 - activeMultiplier) * this.animationProgress;
                    }
                }
                
                return activeMultiplier;
            }
            
            drawWrapTick(angle, isFilled, isCurrent, currentLap, lengthMultiplier = 1.0, showAsGray = false, tickIndex = -1, currentTickIndex = -1, totalTicks = 0) {
                // Base tick dimensions
                const baseLength = 15;
                const actualLength = baseLength * lengthMultiplier;
                
                let innerRadius, outerRadius;
                const lineWidth = 3;
                
                // Calculate positions based on alignment
                switch (this.debugSettings.alignment) {
                    case 'inward':
                        innerRadius = this.radius - 5 - actualLength;
                        outerRadius = this.radius - 5;
                        break;
                    case 'outward':
                        innerRadius = this.radius - 20;
                        outerRadius = this.radius - 20 + actualLength;
                        break;
                    case 'center':
                        const centerPoint = this.radius - 12.5;
                        const halfLength = actualLength / 2;
                        innerRadius = centerPoint - halfLength;
                        outerRadius = centerPoint + halfLength;
                        break;
                }
                
                // Calculate positions
                const x1 = this.centerX + Math.cos(angle) * innerRadius;
                const y1 = this.centerY + Math.sin(angle) * innerRadius;
                const x2 = this.centerX + Math.cos(angle) * outerRadius;
                const y2 = this.centerY + Math.sin(angle) * outerRadius;
                
                // Use standard coloring system
                let strokeColor;
                
                if (this.debugSettings.gradientColorMode === 'seamless') {
                    // Seamless mode: apply gradient regardless of fill status or showAsGray
                    if (isCurrent) {
                        strokeColor = '#FA4947';
                    } else {
                        strokeColor = this.getConicGradientColor(angle, currentTickIndex, totalTicks, this.debugSettings.gradientColorMode);
                    }
                } else if (showAsGray) {
                    strokeColor = BASE_GRAY;
                } else if (this.debugSettings.gradientColorMode === 'standard') {
                    strokeColor = isFilled ? '#FA4947' : BASE_GRAY;
                } else {
                    // Regular gradient mode: only apply to filled ticks
                    strokeColor = isFilled
                        ? (isCurrent ? '#FA4947' : this.getConicGradientColor(angle, currentTickIndex, totalTicks, this.debugSettings.gradientColorMode))
                        : BASE_GRAY;
                }
                
                // Draw the tick
                this.ctx.save();
                
                this.ctx.beginPath();
                this.ctx.moveTo(x1, y1);
                this.ctx.lineTo(x2, y2);
                this.ctx.strokeStyle = strokeColor;
                this.ctx.lineWidth = lineWidth;
                this.ctx.lineCap = 'round';
                this.ctx.stroke();
                
                this.ctx.restore();
            }
            
            getConicGradientColor(angle, currentTickIndex, totalTicks, mode = 'gradient') {
                // If we don't have a valid current tick, fall back to plain white for that tick only
                if (currentTickIndex < 0 || totalTicks <= 0) return 'rgb(255,255,255)';

                // Normalize: 12 o'clock = 0, increases clockwise [0, 2π)
                let normalizedAngle = (angle + Math.PI / 2) % (2 * Math.PI);
                if (normalizedAngle < 0) normalizedAngle += 2 * Math.PI;

                // Current tick position in radians, 12 o'clock = 0, clockwise
                const currentTickAngle = (currentTickIndex * 2 * Math.PI) / totalTicks;

                if (mode === 'seamless') {
                    // Seamless mode: 20% gradient trail that follows the current position
                    const trailLength = 2 * Math.PI * 0.2; // 20% of full circle
                    
                    // Calculate the start of the gradient trail (20% before current position)
                    let trailStartAngle = currentTickAngle - trailLength;
                    if (trailStartAngle < 0) trailStartAngle += 2 * Math.PI;
                    
                    
                    // Check if this tick is within the 20% trail
                    let isInTrail = false;
                    let trailProgress = 0;
                    
                    const tolerance = 0.001; // Small tolerance for floating point comparisons
                    
                    if (trailStartAngle <= currentTickAngle + tolerance) {
                        // Normal case: trail doesn't wrap around
                        isInTrail = normalizedAngle >= trailStartAngle - tolerance && normalizedAngle <= currentTickAngle + tolerance;
                        if (isInTrail) {
                            trailProgress = Math.max(0, Math.min(1, (normalizedAngle - trailStartAngle) / trailLength));
                        }
                    } else {
                        // Wrap case: trail wraps around 0/2π boundary
                        isInTrail = normalizedAngle >= trailStartAngle - tolerance || normalizedAngle <= currentTickAngle + tolerance;
                        if (isInTrail) {
                            if (normalizedAngle >= trailStartAngle - tolerance) {
                                trailProgress = Math.max(0, Math.min(1, (normalizedAngle - trailStartAngle) / trailLength));
                            } else {
                                trailProgress = Math.max(0, Math.min(1, (normalizedAngle + 2 * Math.PI - trailStartAngle) / trailLength));
                            }
                        }
                    }
                    
                    if (isInTrail) {
                        // Interpolate from BASE_GRAY to white within the trail
                        const start = 67;  // BASE_GRAY channel value
                        const end = 255;   // white
                        const r = Math.round(start + (end - start) * trailProgress);
                        const g = r;
                        const b = r;
                        return `rgb(${r}, ${g}, ${b})`;
                    } else {
                        // Outside the trail: unaffected gray
                        return BASE_GRAY;
                    }
                } else {
                    // Original gradient mode logic
                    // If current is exactly 12 o'clock, only that tick should be white; others unaffected gray.
                    if (currentTickAngle === 0) {
                        // Only the tick at 12 o'clock should be white (current position).
                        return normalizedAngle === 0 ? 'rgb(255,255,255)' : BASE_GRAY;
                    }

                    // If the tick's angle lies within the sweep [0, currentTickAngle] (clockwise),
                    // map it from BASE_GRAY (start at 12 o'clock) → white (end at current). Outside: unaffected BASE_GRAY.
                    if (normalizedAngle <= currentTickAngle) {
                        const progress = normalizedAngle / currentTickAngle; // 0 → 1

                        // Interpolate from BASE_GRAY (#434343 → 67) to white (255)
                        const start = 67;           // #434343 channel value
                        const end = 255;            // white
                        const r = Math.round(start + (end - start) * progress);
                        const g = r;
                        const b = r;
                        return `rgb(${r}, ${g}, ${b})`;
                    }

                    // Outside the sweep (i.e., after the current tick): unaffected gray
                    return BASE_GRAY;
                }
            }
            
            drawTick(angle, isFilled, isCurrent, isPhaseB, lengthMultiplier = 1.0, isNext = false, progress = 0, tickIndex = -1, currentTickIndex = -1, totalTicks = 0) {
                // Base tick dimensions
                const baseLength = 15; // Base tick length
                const actualLength = baseLength * lengthMultiplier;
                
                let innerRadius, outerRadius;
                
                // Set line width based on phase and tick mode
                let lineWidth;
                if (isPhaseB && this.debugSettings.tickMode === '15min') {
                    lineWidth = 1.5; // Thinner for 15-min mode (285 ticks)
                } else {
                    lineWidth = 3; // Normal thickness for other modes
                }
                
                // Calculate positions based on alignment
                switch (this.debugSettings.alignment) {
                    case 'inward':
                        // Grows inward from outer edge
                        innerRadius = this.radius - 5 - actualLength;
                        outerRadius = this.radius - 5;
                        break;
                    case 'outward':
                        // Grows outward from inner edge
                        innerRadius = this.radius - 20;
                        outerRadius = this.radius - 20 + actualLength;
                        break;
                    case 'center':
                        // Grows from center point
                        const centerPoint = this.radius - 12.5; // Middle of normal tick
                        const halfLength = actualLength / 2;
                        innerRadius = centerPoint - halfLength;
                        outerRadius = centerPoint + halfLength;
                        break;
                }
                
                // Calculate positions
                const x1 = this.centerX + Math.cos(angle) * innerRadius;
                const y1 = this.centerY + Math.sin(angle) * innerRadius;
                const x2 = this.centerX + Math.cos(angle) * outerRadius;
                const y2 = this.centerY + Math.sin(angle) * outerRadius;
                
                // Determine color
                let strokeColor;
                
                if (this.debugSettings.gradientColorMode === 'standard') {
                    // Standard color mode
                    if (isFilled) {
                        strokeColor = '#FA4947'; // Filled ticks are red
                    } else if (isNext && isPhaseB && this.debugSettings.tickMode === 'hourly') {
                        // Next tick in hourly mode cycles through opacity based on progress
                        // Starts grey, then progressively becomes red
                        if (progress === 0) {
                            strokeColor = BASE_GRAY; // Grey when exactly on the hour
                        } else {
                            // Map progress to 25%, 50%, 75%, 100% opacity at quarter intervals
                            let opacity;
                            if (progress < 0.25) {
                                opacity = 0.25 * (progress / 0.25); // 0 to 25%
                            } else if (progress < 0.5) {
                                opacity = 0.25 + 0.25 * ((progress - 0.25) / 0.25); // 25% to 50%
                            } else if (progress < 0.75) {
                                opacity = 0.5 + 0.25 * ((progress - 0.5) / 0.25); // 50% to 75%
                            } else {
                                opacity = 0.75 + 0.25 * ((progress - 0.75) / 0.25); // 75% to 100%
                            }
                            
                            // Create rgba color with calculated opacity
                            const red = 255;
                            const green = 0;
                            const blue = 0;
                            strokeColor = `rgba(${red}, ${green}, ${blue}, ${opacity})`;
                        }
                    } else {
                        strokeColor = BASE_GRAY; // Unfilled ticks are gray
                    }
                } else {
                    // Gradient color modes: current = red, others use conic gradient
                    if (this.debugSettings.gradientColorMode === 'seamless') {
                        // Seamless mode: apply gradient regardless of fill status
                        if (isCurrent) {
                            strokeColor = '#FA4947';
                        } else {
                            strokeColor = this.getConicGradientColor(angle, currentTickIndex, totalTicks, this.debugSettings.gradientColorMode);
                        }
                    } else {
                        // Regular gradient mode: only apply to filled ticks
                        if (isFilled) {
                            strokeColor = isCurrent ? '#FA4947' : this.getConicGradientColor(angle, currentTickIndex, totalTicks, this.debugSettings.gradientColorMode);
                        } else {
                            strokeColor = BASE_GRAY;
                        }
                    }
                }
                
                // Draw the tick with smooth transition
                this.ctx.save();
                
                this.ctx.beginPath();
                this.ctx.moveTo(x1, y1);
                this.ctx.lineTo(x2, y2);
                this.ctx.strokeStyle = strokeColor;
                this.ctx.lineWidth = lineWidth;
                this.ctx.lineCap = 'round';
                this.ctx.stroke();
                
                this.ctx.restore();
            }
        }
        
        function toggleDebug() {
            const panel = document.getElementById('debugPanel');
            const toggleBtn = document.getElementById('debugToggle');
            
            panel.classList.toggle('open');
            toggleBtn.textContent = panel.classList.contains('open') ? 'Close' : 'Open animation controls';
        }
        
        // Initialize the dial
        new CircularTimeDial();
    </script>
</body>
</html>